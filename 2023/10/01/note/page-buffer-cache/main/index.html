
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Page/Buffer Cache 是什么？ | jyi2ya 的博客</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/solarized-light.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css">
    <link rel="stylesheet" href="/custom.css"/>
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/icon512.png">
    <meta name="theme-color" content="#ffffff"/>
    
  <meta name="generator" content="Hexo 8.0.0"></head>
  <body>
    <script>
      if ('serviceWorker' in navigator && false) {
        window.addEventListener('load', function () {
          navigator.serviceWorker.register('/sw.js', {scope: '/'})
            .then(function (registration) {
              // console.log('ServiceWorker registration successful with scope: ', registration.scope);
            })
            .catch(function (err) {
              console.log('ServiceWorker registration failed: ', err);
            });
        });
      }
    </script>
  <div id="page-container">
    <nav class="navbar nav-shadow" role="navigation" aria-label="main navigation">
  <div class="container">
      <div class="navbar-brand">
          <a class="navbar-item" href="/">
              <img src="/icon192.png" height="50">
          </a>
          <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false"
             data-target="mainNavbar">
              <span aria-hidden="true"></span>
              <span aria-hidden="true"></span>
              <span aria-hidden="true"></span>
          </a>
      </div>
      <div id="mainNavbar" class="navbar-menu">
          <div class="navbar-start">
              <a class="navbar-item" href="/"> jyi2ya 的博客 </a>
              <a class="navbar-item" href="/archives"> Archives </a>
              <a class="navbar-item" href="/about"> About </a>
          </div>
      </div>
  </div>
</nav>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  if ($navbarBurgers.length > 0) {
    $navbarBurgers.forEach( el => {
      el.addEventListener('click', () => {
        const target = el.dataset.target;
        const $target = document.getElementById(target);
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');
      });
    });
  }
});
</script>
    <div id="content-wrap">
        <div class="container">
          <div class="article-container">
  <h1 class="title is-3 is-4-mobile">Page/Buffer Cache 是什么？</h1>
  <article>
      <div class="contents">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Cache"><span class="toc-text">Page Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer-Cache"><span class="toc-text">Buffer Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">两者的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="toc-text">一些比较复杂的东西</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#page-cache-%E5%92%8C-buffer-cache-%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-text">page cache 和 buffer cache 其实是一个东西？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6-page-cache-%E4%B8%8E-buffer-cache-%E5%90%88%E5%B9%B6%E4%BA%86%E2%80%A6%E2%80%A6"><span class="toc-text">既然 page cache 与 buffer cache 合并了……</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">一些好玩的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A5%E7%82%B9%E6%96%87%E4%BB%B6%E9%A2%84%E8%AF%BB"><span class="toc-text">来点文件预读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%89%E8%90%BD%E6%93%A6%E8%BD%A6"><span class="toc-text">掉落擦车</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C"><span class="toc-text">未解之谜</span></a></li></ol>
      </div>
      <p>Page&#x2F;Buffer Cache 是什么？</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><ul>
<li><p>试图最小化磁盘 IO</p>
</li>
<li><p>本质上是一堆内存页面</p>
</li>
</ul>
<blockquote>
<p>内存页面（Page）：一小段连续内存，是操作系统管理内存的最小单位</p>
</blockquote>
<ul>
<li>包含了很多最近访问过的<strong>文件的内容</strong><ul>
<li>意思是不包括 inode、目录等东西！</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于 inode 和目录来说，他们的 page cache 的类似物分别叫做 inode cache 和 directory entry cache。其中 directory entry cache 又由 inode cache 组织而来。</p>
</blockquote>
<ul>
<li><p>用途广泛，用于 file-backed mmap、buffered io，甚至 swap。</p>
</li>
<li><p>需要文件系统支持</p>
</li>
</ul>
<h2 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a>Buffer Cache</h2><ul>
<li><p>试图最小化磁盘 IO</p>
</li>
<li><p>本质上是内存里的一堆块</p>
</li>
</ul>
<blockquote>
<p>块：操作系统对磁盘操作的基本单位，在 Linux 中要求大小为 2 的整数次幂，且比 sector 大，比 page 小</p>
</blockquote>
<blockquote>
<p>sector：磁盘读写数据的最小单位，由磁盘决定。</p>
</blockquote>
<ul>
<li><p>包含了最近访问过的块</p>
</li>
<li><p>用途不多，基本上只用来加速块设备</p>
</li>
</ul>
<blockquote>
<p>块设备（Block Device）：支持随机读写的设备。典型的比如磁盘。</p>
</blockquote>
<ul>
<li>不需要文件系统</li>
</ul>
<blockquote>
<p>比如，文件系统的 superblock 一般会躺在 buffer cache 里面</p>
</blockquote>
<h2 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h2><p>可以参考下图（从 <a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/publications/library/proceedings/usenix01/full_papers/kroeger/kroeger_html/node8.html">usenix</a> 上面偷的）：</p>
<p><img src="/overview.png" alt="overview.png"></p>
<blockquote>
<p><strong>考古时间</strong></p>
<p>为什么 page cache 是一堆内存页面，而 buffer cache 是一堆块呢？</p>
<p>最开始 Linux 上面只有 buffer cache，此时 buffer cache 仅仅用于加速 buffered io 操作，向上与 read&#x2F;write 交互，向下与磁盘交互。所以 buffer cache 设计成一堆块是很合适的。</p>
<p>page cache 则是为了支持 mmap，在 2.2 版本中引入的。由于它和内存关系比较紧密，所以设计成一堆内存页的形式。不过此时 buffered io 仍然只与 buffer cache 交互，不与 page cache 交互。要等两个 cache 合并之后才会出现大家所熟知的「调用 read&#x2F;write 之后会写 page cache，过一会儿由操作系统把脏页写回磁盘」这种模式。</p>
</blockquote>
<h1 id="一些比较复杂的东西"><a href="#一些比较复杂的东西" class="headerlink" title="一些比较复杂的东西"></a>一些比较复杂的东西</h1><h2 id="page-cache-和-buffer-cache-其实是一个东西？"><a href="#page-cache-和-buffer-cache-其实是一个东西？" class="headerlink" title="page cache 和 buffer cache 其实是一个东西？"></a>page cache 和 buffer cache 其实是一个东西？</h2><p>虽然逻辑上还是可以将他们分为两个东西，但是其实两者只是同一套数据的不同组织方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------+</span><br><span class="line">| page                                  |</span><br><span class="line">|+-------+ +--------+ +--------++------+|</span><br><span class="line">||buffer1| | buffer2| |buffer3 ||buffer||</span><br><span class="line">||       | |        | |        ||  4   ||</span><br><span class="line">|+-------+ +--------+ +--------++------+|</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>

<p>（没找到合适的图所以画了个）</p>
<p>每个 buffer 可以通过 <code>buffer_head</code> 结构体中的 <code>b_page</code> 字段获取自己对应的 page，同时 page 也可以通过 <code>page</code> 结构体中的 <code>buffers</code> 字段来得到自己所拥有的一组 buffer。</p>
<h2 id="既然-page-cache-与-buffer-cache-合并了……"><a href="#既然-page-cache-与-buffer-cache-合并了……" class="headerlink" title="既然 page cache 与 buffer cache 合并了……"></a>既然 page cache 与 buffer cache 合并了……</h2><p>那如果我在 A 进程对 <code>/dev/sda1</code> 上的一个文件 F 的一个连续区域做 shared mmap，再在 B 进程对 <code>/dev/sda</code> 本身做 shared mmap，两个进程映射的实际磁盘空间一致，那 A 进程与 B 进程能映射到同一个 page 吗？</p>
<p>答案是不行 :3。因为 A 进程的 page 是文件系统给的，而 B 进程得到的东西更像是一堆 buffer 组合成的 page。</p>
<p>此时数据组织大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------+  +---------------------------------------+</span><br><span class="line">| A page                                |  | B page                                |</span><br><span class="line">|                                       |  |                                       |</span><br><span class="line">|                                       |  |                                       |</span><br><span class="line">|    o         o          o           o |  |   o       o          o         o      |</span><br><span class="line">|    |         |          |           | |  |   |       |          |         |      |</span><br><span class="line">+----|---------|----------|-----------|-+  +---|-------+----------+---------+------+</span><br><span class="line">     v         v          v           v        |       |          |         |</span><br><span class="line"> +-------+ +--------+ +--------+   +------+    |       |          |         |</span><br><span class="line">`|buffer1| | buffer2| |buffer3 |   |buffer|    |       |          |         |</span><br><span class="line"> |       | |        | |        |   |  4   |    |       |          |         |</span><br><span class="line"> +---^---+ +---^----+ +---^----+   +--^---+    |       |          |         |</span><br><span class="line">     +---------+----------|-----------+--------+       |          |         |</span><br><span class="line">               +----------|-----------+----------------+          |         |</span><br><span class="line">                          +-----------+---------------------------+         |</span><br><span class="line">                                      +---------------------------+---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一些好玩的接口"><a href="#一些好玩的接口" class="headerlink" title="一些好玩的接口"></a>一些好玩的接口</h1><h2 id="来点文件预读"><a href="#来点文件预读" class="headerlink" title="来点文件预读"></a>来点文件预读</h2><p>除了缓存已经读过&#x2F;写过的数据之外，猜测程序要读什么从而提前把它们读进 page cache 中，也能加快程序！</p>
<ul>
<li><p>posix_fadvise(2): <code>POSIX_FADV_SEQUENTIAL</code> 参数可以暗示内核自己将要顺序读文件。</p>
</li>
<li><p>madvise(2): <code>MADV_SEQUENTIAL</code> 参数可以暗示内核自己将顺序使用一些内存，配合 <code>mmap(2)</code> 使用。</p>
</li>
<li><p>readahead(2)：简单直接地告诉内核，偷偷多读一些东西（感觉这是个没用的屑调用……）。</p>
</li>
</ul>
<h2 id="掉落擦车"><a href="#掉落擦车" class="headerlink" title="掉落擦车"></a>掉落擦车</h2><p>可以通过 <code>/proc/sys/vm/drop_caches</code> 来告知内核扔掉一些 cache 数据。可以通过 <code>echo X &gt; /proc/sys/vm/drop_caches</code> 来使用。其中 X 的取值可以为 1, 2 或 3。当 X 为 1 时意思是让内核扔掉所有 page cache 里面的数据。2 和 3 代表什么，不知道 :3。</p>
<p>在测试一些 io-bounded 的程序时，为了防止 page cache 对测量结果造成干扰，可以在测试前运行一下。</p>
<h1 id="未解之谜"><a href="#未解之谜" class="headerlink" title="未解之谜"></a>未解之谜</h1><p>发现自己还是不太看得懂 <code>free(1)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            13Gi       4.4Gi       3.2Gi       135Mi       6.5Gi       9.1Gi</span><br></pre></td></tr></table></figure>

      <p class="copyright"><strong>Links: <a href="https://jyi2ya.github.io/2023/10/01/note/page-buffer-cache/main/">https://jyi2ya.github.io/2023/10/01/note/page-buffer-cache/main/</a></strong></p>
  </article>
  <div id="comment">
    
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function() {
        this.page.url = "https://jyi2ya.github.io/2023/10/01/note/page-buffer-cache/main/"; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = "cuidpeNTNasJbS3VYe6q2GWGu"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };
  
      (function() {
        var d = document,
          s = d.createElement("script");
        s.src = "https://iometa.disqus.com/embed.js";
        s.setAttribute("data-timestamp", +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    
</div>
</div>
        </div>
    </div>
    
<footer id="footer">
    <div class="content has-text-centered">
        <p>
            © 2025 <a href="https://jyi2ya.github.io">jyi2ya</a>.
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>.
            Theme <a target="_blank" rel="noopener" href="https://github.com/songquanpeng/hexo-theme-lightx">lightx</a>.
            
        </p>
    </div>
</footer>
  </div>
  
    <script id="dsq-count-scr" src="//iometa.disqus.com/count.js" async></script>
  
  
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  </body>
</html>
