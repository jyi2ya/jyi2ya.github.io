<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><!-- hexo injector head_begin start --><script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- hexo injector head_begin end -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="好用的 non-root 包管理器推荐 —— pkgsrc我们登录一个集群时，通常会期望集群上已经安装了自己常用的所有软件，并且都是最新版本的。但事实上，很多机器仍然在老掉牙的操作系统上使用古董软件。比如，最近打比赛的 X 威·X 海一号的机器，用的就是连 namespace 都没开的 CentOS">
    

    <!--Author-->
    
        <meta name="author" content="jyi2ya">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Hexo"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover for sharing-->
    
        <meta property="og:image" content="https://i❤️.ws/emoji-image/🦄.png" />
    

    <!-- Page permalink -->
    
        <meta property="og:url" content="https://jyi2ya.github.io/2023/10/01/tutorial/pkgsrc/main/" />
    

    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@johndoe" />
    

    <meta name="generator" content="Hexo" />

    <!-- Title -->
    
    <title>Hexo</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body class="sans-serif">

<!-- Main Content -->
<!-- Banner -->
<!-- Banner -->
<header class="w-100 bg-1 ph5-ns ph3 text-light">

    <nav class="db w-100 mw8 center border-box pv3">
        <div class="db v-mid w-100 tc tr-ns">
            
            
        </div>
    </nav>

    <div class="w-100 tc db dt-ns">
        <!-- Title -->
        <div class="dib dtc-ns w-90-ns white">
            <h1 class="f1-ns tc tc-ns tl-ns">default_post_title</h1>
        </div>
        <!-- Icon -->
        <div class="dib dtc-ns w-10-ns f1 f-5-ns f-6-l mb2">
            <span class="ec">🧙</span>
        </div>
    </div>
    
</header>


<!-- Content -->
<div class="w-100 ph2 ph4-m ph5-l mv5">
    <div class="content">
        <div class="mw8 center">
            <div class="cf">
                <div class="fl w-100 mw7 left lh-copy pr4-ns pr0-m post-content">

                    <!-- Main Post Content -->
                    <h1 id="好用的-non-root-包管理器推荐-——-pkgsrc"><a href="#好用的-non-root-包管理器推荐-——-pkgsrc" class="headerlink" title="好用的 non-root 包管理器推荐 —— pkgsrc"></a>好用的 non-root 包管理器推荐 —— pkgsrc</h1><p>我们登录一个集群时，通常会期望集群上已经安装了自己常用的所有软件，并且都是最新版本的。但事实上，很多机器仍然在老掉牙的操作系统上使用古董软件。比如，最近打比赛的 X 威·X 海一号的机器，用的就是连 namespace 都没开的 CentOS 7，配备的还是 3.10 的内核， gcc 4.5 和 vim 7.4。而且自己拿到的账号通常都不是 root，也没有 sudo 权限，想给系统的包管理器加 PPA（CentOS 里面有 PPA 这个概念吗？）或者想安装 nix 都没有办法。</p>
<p>为了改善机器使用体验，我在机器上编译了比较新的 tmux 和 git。但是过程体验很糟糕。缺失的各个依赖库都要手动下载、编译，然后放到合适的位置。还要配置一堆奇怪的环境变量，来让工具链能够找到它们。即使大多数软件包都使用了 autotools 或 CMake 这样的构建系统，用工具自动配置编译参数免除了手动修改 Makefile 的烦恼，手动处理软件依赖也是一件费时费力的工作。最后编译出来的 git 应该是漏掉了哪个开关，导致它没法用 https 协议克隆仓库。好在大家用得比较多的是 ssh 协议，这个小缺陷并没有造成很大的影响。</p>
<p>为了改善自己余生里使用古老集群的体验，我决定寻找一个包管理器，它要没有 root 也能用，能够自动处理依赖，并且能够安装最新的软件。</p>
<h2 id="源码安装还是二进制安装？"><a href="#源码安装还是二进制安装？" class="headerlink" title="源码安装还是二进制安装？"></a>源码安装还是二进制安装？</h2><p>按照软件包的形态来说，包管理器大致可以分成源码安装和二进制安装两种。源码安装时，下载的是软件的源代码，编译之后安装到指定位置；而二进制安装时下载的是编译好的软件包，解压到指定位置即可使用。</p>
<p>二进制安装的优点是省时省力省硬盘，无需配齐工具链也可安装软件。大多数 Linux 发行版默认便使用这种包管理的策略，比如 Debian Fedora 等。缺点是不够灵活。</p>
<p>源码安装则通常需要强劲的电脑和完备的工具链。如果软件使用不同的语言开发，还需要配齐每个语言的配套工具。对电脑来说编译通常是一个相当痛苦的过程，编译大型软件会消耗大量的 CPU 时间（软件优化）、硬盘空间（中间产物）和内存（链接）。就我知道的来说，源码安装除了可以高度定制软件，仅编译自己想要的部分，和得到一些（可疑的）性能提升之外，几乎没有什么优点。著名的 Gentoo 便是一个以源码安装著称的 Linux 发行版。</p>
<p>就简单的优劣对比来看，我们应当选择二进制安装的包管理系统。但是由于历史原因（可恶的大家长式的，使用绝对路径的，包办所有的包管理系统），二进制包通常会附带一个缺陷：二进制包的资源文件、可执行文件路径通常默认是固定的，有些甚至直接写在了二进制文件里。例如，假设一个软件在编译时指定其资源文件放在 &#x2F;usr&#x2F;share&#x2F;xyz 中，那么它就只会从这个目录里寻找资源文件；想要修改这个设置，只能重新编译。对于一个完整的、可以控制整个根目录的发行版来说，这当然没有问题，只要在包里写好，把资源文件都放在 &#x2F;usr&#x2F;share&#x2F;xyz 里，软件便能在所有机器上使用。然而，在古老集群上，没人能保证我每次都能拥有一个同样的可写目录（&#x2F;dev&#x2F;shm 和 &#x2F;tmp 除外，它们通常都是可写的，但是太小了，而且一关机就没了）。我在这个机器上的家目录是 &#x2F;home&#x2F;kiana，明天没准就是 &#x2F;home&#x2F;export&#x2F;online1&#x2F;mdt00&#x2F;pqr&#x2F;xyz 了。</p>
<p>有三种主流的方法可以缓解二进制包使用绝对路径的问题。</p>
<p>第一种是 fakechroot。它的原理是使用 LD_PRELOAD 把 libc 中的系统调用函数给替换掉，换成自己的实现。然后在运行时把系统调用的路径参数替换掉，从而实现无 root 的情况下实现 chroot 的效果。这种方案的缺点是，它要求所执行的所有程序必须链接到系统的 libc。换言之，它对静态链接的程序不起作用，实际体验来说，静态链接的程序在 fakechroot 提供的环境里虽然可以运行，但是根本没法用（所以所有 go 程序都直接没用了，go 真是太坏了）。</p>
<p>第二种是 proot。它的原理是通过 ptrace 系统调用拦截软件的系统调用，修改系统调用的参数后再执行。它也能实现类似 chroot 的效果。它甚至还能模拟出类似 <code>mount --bind</code> 的效果，很神奇。可惜由于 ptrace 系统调用具有类似不可重入的特性，导致 proot 提供的环境里没法执行需要用到 ptrace 系统调用的程序。所以，strace ltrace gdb 和 catp 等大家喜闻乐见的小工具都没法用了。</p>
<p>第三种是 namespace。它是某种由内核提供的机制，原理我不太了解。反正我现在用的机器上没有就是了。</p>
<h2 id="pkgsrc-使用指南"><a href="#pkgsrc-使用指南" class="headerlink" title="pkgsrc 使用指南"></a>pkgsrc 使用指南</h2><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><ul>
<li>头歌</li>
<li>神威·问海一号</li>
<li>自家电脑</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>bsd only</li>
<li>无编译器</li>
<li>编译器版本落后</li>
</ul>


                    
                        <div class="pt3">
                            <span class="ec pr2">🕗</span>2023-10-01
                        </div>
                    
                    <!-- Tags Bottom -->
                    

                    <!-- Comments -->
                    

                </div>
            </div>
        </div>
    </div>
</div>


<!-- Footer -->
<footer class="bg-1 ph2 ph5-ns pv5 center tc">
    
</footer>


</body>

</html>