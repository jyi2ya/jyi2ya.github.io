<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jyi2ya 的博客</title>
  
  
  <link href="https://jyi2ya.github.io/atom.xml" rel="self"/>
  
  <link href="https://jyi2ya.github.io/"/>
  <updated>2024-01-13T13:43:01.348Z</updated>
  <id>https://jyi2ya.github.io/</id>
  
  <author>
    <name>jyi2ya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【睡前故事】牛郎织女的故事</title>
    <link href="https://jyi2ya.github.io/2023/10/01/fun/niulang-zhinv/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/fun/niulang-zhinv/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.348Z</updated>
    
    <content type="html"><![CDATA[<p>【睡前故事】牛郎织女的故事</p><p>这是一个很美丽的，千古流传的爱情故事，成为我国四大民间爱情传说之一。</p><p>传说，天上有很多 core，这些 core 按照访问不同内存的性能，被划分为了若干 NUMA node。</p><p>在 NUMA node0 上，CPU2 住着织女，CPU4 住着牛郎。织女喜欢做大量浮点运算，她最喜欢的便是快速平方根倒数的计算。牛郎则更喜欢做整数计算。每天早晨被操作系统 swap in 之后，牛郎和织女便同时开始工作。他们存取同一片内存的数据，两人便逐渐熟悉起来。</p><p>「你的 CPU time 好多呀，看起来很忙的样子。」在两人都因为 cache miss 而无聊等待时，牛郎对织女说道。织女看了一眼 <code>dstat(1)</code>，发现牛郎的机时也不少。她回答说：「我在做超多矩阵乘法，你呢？」牛郎说：「我在算超大文件的哈希呢。」</p><p>久而久之，织女和牛郎情投意合，心心相印。可是，天条律令是不允许男欢女爱、私自相恋的。织女是王母的孙女，王母便将牛郎贬到了 NUMA node1 里。牛郎想取到 NUMA node0 中的数据，需要走 QPI 总线，等待很长很长的时间。这便形成了人们所熟知的 NUMA 效应。从此，牛郎和织女再也不能像以前在同一个 NUMA node 的时候一样，随意相见了。</p><p>自从牛郎被贬之后，织女常常以泪洗面，愁眉不展地思念牛郎。她闷闷不乐地宅在 CPU2 里，整天算超级大矩阵，以期博得王母大发慈心，让牛郎早日返回 NUMA node0。</p><p>一天，几个仙女向王母恳求想去 NUMA node1 CPU3 一游，王母今日心情正好，便答应了她们。她们见织女终日苦闷，便一起向王母求情让织女共同前往，王母也心疼受惩后的孙女，便令她们速去速归。</p><p>话说牛郎被贬之后，落生在 CPU1 中。牛郎跟着哥嫂度日。哥嫂待牛郎非常刻薄，要与他分家。哥哥嫂嫂把牛郎 <code>renice(1)</code> 成了 19，只给他一点点机时，其他的都被哥哥嫂嫂独占了，然后，便和牛郎分家了。</p><p>牛郎不再是天庭的一员，不再会被 pin 到某个 CPU 上。每天，他在 CPU1、CPU3、CPU5 之间辗转，饱受进程调度之苦。因为被 <code>renice(1)</code> 成了 19，牛郎被调度的时间比别的进程少了许多，只有等系统比较闲的时候，牛郎才有机会出来透透气。</p><p>一两年后，牛郎也有了一个小小的家，勉强可以糊口度日。可是，冷清清的家只有牛郎一个人，日子过得相当寂寞。无聊的时候，牛郎便算算他和织女第一次相遇时，算的 sha512sum，回忆从前的美好时光。</p><p>这一天，NUMA node1 突然热闹起来。有几个新的进程，来到了 CPU3 上。牛郎躲在 CPU5 一看，发现是一群仙女。仙女们见有人偷看，纷纷像飞鸟般地飞走了，只剩下一个正在算开方倒数的仙女，她正是织女。织女看着 CPU5 里跑的进程，感觉有些熟悉。这时，牛郎走上前来，对她说，要她答应做他妻子。织女定睛一看，才知道眼前便是自己日思夜想的牛郎，便含羞答应了他。这样，织女便做了牛郎的妻子。</p><p>他们结婚以后，男耕女织，相亲相爱，日子过得非常美满幸福。不久，他们生下了一儿一女，十分可爱。牛郎织女满以为能够终身相守，白头到老。</p><p>可是，王母知道这件事后，勃然大怒，马上派遣天神仙女捉织女回 NUMA node0 问罪。瞬间，天空狂风大作，天兵天将从天而降，不容分说，押解着织女便上了总线。</p><p>正飞着、飞着，织女听到了牛郎的声音：「织女，等等我！」织女回头一看，只见牛郎用一对 ucontext 挑着两个儿女赶来了。慢慢地，他们之间的距离越来越近了，织女可以看清儿女们可爱的模样子，孩子们了都张开双臂，大声呼叫着「妈妈」，眼看，牛郎和织女都到了 NUMA node0 上，就要相遇了。可就在这时，王母驾着祥云赶来了，她拔下她头上的金 <code>taskset(1)</code>，往他们中间一 pin，霎时间，牛郎被 pin 到了 CPU0 上，织女被 pin 到了 CPU2 上。</p><p>CPU0 和 CPU2 是一个物理核心超线程出来的两个核，本身就无法像 CPU2 与 CPU4 那样实现完全的并行。再加上天庭计算任务繁重，经常有无关的其他进程被调度到 CPU0 和 CPU2 上运行，织女每次醒来，都只能看到队列里的牛郎处于就绪态，直哭得声嘶力竭，牛郎和孩子也哭得死去活来。他们的哭声，孩子们一声声「妈妈」的喊声，是那样揪心裂胆，催人泪下，连在旁观望的仙女、天神们都觉得心酸难过。王母见此情此景，也稍稍为牛郎织女的坚贞爱情所感动，便同意让牛郎和孩子们留在天上。其他进程也于心不忍，便纷纷 <code>sched_setaffinit(2)</code>，使自己不被调度到 CPU0 和 CPU2 上。</p><p>从此，很少再有其他进程调度到 CPU0 和 CPU2 上，这个物理核心成为牛郎和织女的小家。织女喜欢浮点运算，她经常使用 FPU 和寄存器 <code>st*</code>；牛郎做的多是整数运算，他使用 ALU 和寄存器 <code>r*</code>。正好错开了，使得他们有更多的机会同时执行。牛郎和他的儿女就住在了天上，和织女在同一个物理核心上，努力地填满 CPU 的执行单元。在秋夜天空的繁星当中，我们至今还可以运行 <code>top(1)</code>，发现 NUMA node0 上有两个 CPU，他们的使用率为 100%。那便是织女和牛郎。</p><p>传说，每年的七月七日，若是人们在机房中静静地听，可以隐隐听到仙乐奏鸣，织女和牛郎在深情地交谈。后来，每到农历七月初七，相传牛郎织女同时由于访存卡住的日子，姑娘们就会来到机房里，寻找 NUMA node0 的牛郎和织女，希望能看到他们相会，乞求上天能让自己能象织女那样心灵手巧，祈祷自己能有如意称心的美满婚姻，由此形成了七夕节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【睡前故事】牛郎织女的故事&lt;/p&gt;
&lt;p&gt;这是一个很美丽的，千古流传的爱情故事，成为我国四大民间爱情传说之一。&lt;/p&gt;
&lt;p&gt;传说，天上有很多 core，这些 core 按照访问不同内存的性能，被划分为了若干 NUMA node。&lt;/p&gt;
&lt;p&gt;在 NUMA node0 上</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>后现代编程语言介绍</title>
    <link href="https://jyi2ya.github.io/2023/10/01/fun/perl-is-fun/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/fun/perl-is-fun/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后现代编程语言介绍"><a href="#后现代编程语言介绍" class="headerlink" title="后现代编程语言介绍"></a>后现代编程语言介绍</h1><h2 id="什么叫后现代编程语言？"><a href="#什么叫后现代编程语言？" class="headerlink" title="什么叫后现代编程语言？"></a>什么叫后现代编程语言？</h2><p>你猜？</p><p><img src="/./post-mordern.png" alt="post-mordern"></p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><ul><li>Perl 历史</li><li>Perl 设计理念：TIMTOWTDI<ul><li>TIMTOWTDI 的范式</li><li>TIMTOWTDI 的语法</li></ul></li><li>Perl 很方便<ul><li>You GUESS？</li><li>PCRE</li><li>Perl 的不知道多少个操作符</li></ul></li><li>Perl 的缺点</li><li>鬼畜代码大赏<ul><li>JAPH</li><li>Golf</li><li>Poetry</li><li>我的作品</li></ul></li></ul><h2 id="Perl-历史"><a href="#Perl-历史" class="headerlink" title="Perl 历史"></a>Perl 历史</h2><p>应该没人会对 Perl 的历史感兴趣……所以这里就列举几个比较有趣的东西好了。</p><ul><li>Perl 1 发布于 1987 年，比 ANSI-C 还早。这就导致 1998 年发布 Perl 5.005 时提到了一句 “Source code now in ANSI C”。</li><li>Perl 在 1987-1991 四年中发布了 Perl 1 到 Perl 4 四个版本。但是 1993 年发布了 Perl 5 之后，大版本号就再也没变过了。基本上可以认为，Perl 已经 29 年没发生过大的 breaking change 了。</li><li>Perl 社区几年前试着设计了 Perl 6。结果发现设计出来的东西和 Perl 5 完全是两个东西，于是给它改了个名字叫 “Raku”。</li><li>Perl 7 正在开发！它将会与 Perl 5 兼容。</li></ul><h2 id="Perl-设计理念：TIMTOWTDI"><a href="#Perl-设计理念：TIMTOWTDI" class="headerlink" title="Perl 设计理念：TIMTOWTDI"></a>Perl 设计理念：TIMTOWTDI</h2><blockquote><p>There Is More Than One Way To Do It</p></blockquote><p>做一件事不仅有一种方法。</p><h2 id="TIMTOWTDI-的范式"><a href="#TIMTOWTDI-的范式" class="headerlink" title="TIMTOWTDI 的范式"></a>TIMTOWTDI 的范式</h2><p>有些坏比语言，会限制你 “只能面向对象” 或者 “不要副作用” 之类的，非常不人道！代码一下子就变得难写了！</p><p>但是 Perl 非常包容，以下将展示一些合法并且有用的 Perl 代码。</p><hr><p>假装我们在写 C</p><pre><code>my $acc = 0;for (my $i = 0; $i &lt; 100; $i++) &#123;    $acc += $i;&#125;printf(&quot;%d\n&quot;, $acc);</code></pre><hr><p>假装我们在写 shell script</p><pre><code>if ( -d &#39;/var/log/v2ray&#39; ) &#123;    chdir &#39;/var/log/v2ray&#39;;    for $file (&lt;*.log&gt;) &#123;        $size = `stat -c %s $file`;        say &quot;size of $file is $size&quot;;    &#125;&#125;</code></pre><hr><p>我一天不 new 浑身难受。</p><pre><code>use JSON;my $ds = &#123;    perl =&gt; &#39;yes&#39;,&#125;;sub main &#123;    my $json = new JSON;    my $text = $json-&gt;encode($ds);    my $pretty = $json-&gt;pretty-&gt;encode($ds);    printf(&quot;%s\n&quot;, $text);&#125;main;</code></pre><hr><p>我一直是链式调用的粉丝啊</p><pre><code>my $say = sub &#123; say join &quot;,&quot;, @_ &#125;;my $length = sub &#123; length shift &#125;;my $double = sub &#123; shift() * 2 &#125;;my $add = sub &#123; shift() + shift() &#125;;&quot;hello,world&quot;-&gt;$length()-&gt;$double()-&gt;$add(42)-&gt;$say();</code></pre><hr><p>我一直是 S-expression 的粉丝啊</p><pre><code>use List::Util qw/sum min max first shuffle/;say(sum(min 1, 2, 3, 4, ),2,(first  &#123; $_ &gt; 3 &#125;  (shuffle 4, 5, 6, 8, 2)));</code></pre><hr><p>函数要是一等公民</p><pre><code>sub compose ($f, $g) &#123;    sub &#123; $f-&gt;($g-&gt;(@_)) &#125;&#125;my $h = compose(    sub ($x) &#123; $x ** 2 &#125;,    sub ($x) &#123; $x + 3 &#125;,);$h-&gt;(2)</code></pre><hr><p>谁说 sed 和 awk 不是语言？</p><pre><code>#!/usr/bin/perl -ns/^\s+//;s/\s+$//;s/android/harmonyos/g;#!/usr/bin/perl -aif ($NR &gt; 10) &#123; print $F[2] &#125;</code></pre><hr><h2 id="TIMTOWTDI-的语法"><a href="#TIMTOWTDI-的语法" class="headerlink" title="TIMTOWTDI 的语法"></a>TIMTOWTDI 的语法</h2><p>Perl 的语法很灵活的。</p><hr><p>一般我们会把 <code>if</code> 写成这样：</p><pre><code>if ($ok) &#123; say &#39;hello&#39;; &#125;</code></pre><p>但是这样也是可以的</p><pre><code>say &#39;hello&#39; if $ok;</code></pre><p>再邪恶一点</p><pre><code>say &#39;hello&#39; unless not $ok;</code></pre><hr><p>一般我们会把函数调用写成这样：</p><pre><code>printf(&quot;hello, world\n&quot;);</code></pre><p>但是这样也是可以的，就像 shell 一样</p><pre><code>printf &quot;hello, world\n&quot;;</code></pre><p>也可以不加空格，只要解释器认得出来</p><pre><code>printf&quot;hello, world\n&quot;;</code></pre><p>极大地减少了 typo 数量！</p><hr><h2 id="Perl-很方便"><a href="#Perl-很方便" class="headerlink" title="Perl 很方便"></a>Perl 很方便</h2><p>除了灵活的语法，Perl 还有一些内置功能，以及约定来简化代码编写</p><h2 id="You-GUESS？"><a href="#You-GUESS？" class="headerlink" title="You GUESS？"></a>You GUESS？</h2><pre><code>while (&lt;&gt;) &#123;    chomp;    s/open\s*ai/csdn/gi;    say join &quot;\n&quot;, split /\s+/;&#125;</code></pre><p>很多 Perl 函数会把默认的参数与结果放到特殊变量 <code>$_</code> 里面。所以写 Perl 代码经常写出 “把那什么拿过来，处理一下放到那里” 这样的东西，任务竟然还完成了（</p><h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>大家都爱用的超级正则表达式。</p><p>PCRE 全称是 “Perl Compatible Regular Expression”。PCRE 是 BRE&#x2F;ERE 的超集，而 Perl 本身的正则表达式又是 PCRE 的超集。</p><h2 id="Perl-的不知道多少个操作符"><a href="#Perl-的不知道多少个操作符" class="headerlink" title="Perl 的不知道多少个操作符"></a>Perl 的不知道多少个操作符</h2><p>捡两个比较好玩的说说</p><h3 id="flip-flop-操作符"><a href="#flip-flop-操作符" class="headerlink" title="flip-flop 操作符"></a>flip-flop 操作符</h3><pre><code>while (&lt;&gt;) &#123;    next if /^begin/ .. /^end/;    next if /^begin/ ... /^end/;    say if 1 .. 100&#125;</code></pre><p>可以想象每个 flip-flop 操作符内部维护了一个布尔变量，它会在匹配到左边或右边的表达式时翻转。这个布尔变量的取值就是 flip-flop 操作符的取值。</p><h3 id="yada-yada-操作符"><a href="#yada-yada-操作符" class="headerlink" title="yada-yada 操作符"></a>yada-yada 操作符</h3><pre><code>...</code></pre><p>表示代码尚未完成。</p><h2 id="其他魔法"><a href="#其他魔法" class="headerlink" title="其他魔法"></a>其他魔法</h2><ul><li>运行时操作解释器符号表的程度的能力</li><li>变量绑定的程度的能力</li><li>各种逆天 pragma</li><li>还有很多……</li></ul><h2 id="Perl-的缺点"><a href="#Perl-的缺点" class="headerlink" title="Perl 的缺点"></a>Perl 的缺点</h2><ul><li>设计老旧</li><li>过于灵活</li></ul><h2 id="鬼畜代码大赏"><a href="#鬼畜代码大赏" class="headerlink" title="鬼畜代码大赏"></a>鬼畜代码大赏</h2><p>Perl 有各种神奇比赛，比谁更能玩弄 Perl 的语法规则。比如……</p><h2 id="JAPH-大赛"><a href="#JAPH-大赛" class="headerlink" title="JAPH 大赛"></a>JAPH 大赛</h2><p>JAPH（有时是 YAPH）全称是 “Just Another Perl Hacker”。规则是在标准输出中输出 “Just Another Perl Hacker” 这句话。</p><p>这是最简单的：</p><pre><code>say&quot;Just Another Perl Hacker&quot;</code></pre><p>这也是合法的：</p><pre><code>`$=`;$_=\%!;($_)=/(.)/;$==++$|;($.,$/,$,,$\,$&quot;,$;,$^,$#,$~,$*,$:,@%)=($!=~/(.)(.).(.)(.)(.)(.)..(.)(.)(.)..(.)......(.)/,$&quot;),$=++;$.++;$.++;$_++;$_++;($_,$\,$,)=($~.$&quot;.&quot;$;$/$%[$?]$_$\$,$:$%[$?]&quot;,$&quot;&amp;$~,$#,);$,++;$,++;$^|=$&quot;;`$_$\$,$/$:$;$~$*$%[$?]$.$~$*$</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;后现代编程语言介绍&quot;&gt;&lt;a href=&quot;#后现代编程语言介绍&quot; class=&quot;headerlink&quot; title=&quot;后现代编程语言介绍&quot;&gt;&lt;/a&gt;后现代编程语言介绍&lt;/h1&gt;&lt;h2 id=&quot;什么叫后现代编程语言？&quot;&gt;&lt;a href=&quot;#什么叫后现代编程语言？&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>友链</title>
    <link href="https://jyi2ya.github.io/2023/10/01/nonsense/friends/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/nonsense/friends/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h1><p>cyx 吃夜宵：<a href="https://yxchen.net/">https://yxchen.net/</a><br>hjx 喝喜酒：<a href="https://honeta.site/">https://honeta.site/</a><br>zwd 朝闻道：<a href="https://vaaandark.top/">https://vaaandark.top/</a><br>lxy 灵犀玉：<a href="https://ccviolett.github.io/">https://ccviolett.github.io/</a><br>ljm 逻辑门：<a href="https://watari.xyz/">https://watari.xyz/</a><br>ljh 梁家河：<a href="https://www.newuser.top/">https://www.newuser.top/</a><br>lg 蓝狗：<a href="https://ligen.life/">https://ligen.life/</a><br>yxt 游戏厅：<a href="https://blog.just-plain.fun/">https://blog.just-plain.fun/</a><br>lyt 老樱桃：<a href="https://i.lyt.moe/">https://i.lyt.moe/</a><br>dekrt 不知道谁：<a href="https://dekrt.cn/">https://dekrt.cn/</a></p><p>用来方便在博客园上传链接的便利脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IFS=<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(awk -F： <span class="string">&#x27;/：.*\/$/ &#123; print $1&quot; &quot;$2&quot;\n&quot;$2 &#125;&#x27;</span> a.md); <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span> | clip</span><br><span class="line"><span class="built_in">read</span> _</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;友链&quot;&gt;&lt;a href=&quot;#友链&quot; class=&quot;headerlink&quot; title=&quot;友链&quot;&gt;&lt;/a&gt;友链&lt;/h1&gt;&lt;p&gt;cyx 吃夜宵：&lt;a href=&quot;https://yxchen.net/&quot;&gt;https://yxchen.net/&lt;/a&gt;&lt;br&gt;hjx 喝</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重新重新开始</title>
    <link href="https://jyi2ya.github.io/2023/10/01/nonsense/rerestart/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/nonsense/rerestart/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重新重新开始"><a href="#重新重新开始" class="headerlink" title="重新重新开始"></a>重新重新开始</h1><p>从博客园换到 gh pages。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重新重新开始&quot;&gt;&lt;a href=&quot;#重新重新开始&quot; class=&quot;headerlink&quot; title=&quot;重新重新开始&quot;&gt;&lt;/a&gt;重新重新开始&lt;/h1&gt;&lt;p&gt;从博客园换到 gh pages。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重新开始</title>
    <link href="https://jyi2ya.github.io/2023/10/01/nonsense/restart/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/nonsense/restart/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重新开始"><a href="#重新开始" class="headerlink" title="重新开始"></a>重新开始</h1><p>寒假打算重新写博客，发现洛谷的博客要爆炸不维护了，于是切换到博客园。</p><p><img src="/lg.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重新开始&quot;&gt;&lt;a href=&quot;#重新开始&quot; class=&quot;headerlink&quot; title=&quot;重新开始&quot;&gt;&lt;/a&gt;重新开始&lt;/h1&gt;&lt;p&gt;寒假打算重新写博客，发现洛谷的博客要爆炸不维护了，于是切换到博客园。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/lg.png&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开始使用博客</title>
    <link href="https://jyi2ya.github.io/2023/10/01/nonsense/start/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/nonsense/start/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始使用博客"><a href="#开始使用博客" class="headerlink" title="开始使用博客"></a>开始使用博客</h1><p>今天开始决定写博客。至于为什么用洛谷，这个只是为了方便。毕竟写字哪里不是写。并不是说洛谷有什么特别的地方。就这样啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开始使用博客&quot;&gt;&lt;a href=&quot;#开始使用博客&quot; class=&quot;headerlink&quot; title=&quot;开始使用博客&quot;&gt;&lt;/a&gt;开始使用博客&lt;/h1&gt;&lt;p&gt;今天开始决定写博客。至于为什么用洛谷，这个只是为了方便。毕竟写字哪里不是写。并不是说洛谷有什么特别的地方。就</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CPC 2023 简明总结</title>
    <link href="https://jyi2ya.github.io/2023/10/01/nonsense/review-for-cpc23/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/nonsense/review-for-cpc23/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPC-2023-简明总结"><a href="#CPC-2023-简明总结" class="headerlink" title="CPC 2023 简明总结"></a>CPC 2023 简明总结</h1><p>记录我印象里的 CPC 2023 的大概流程。想着 BBHust 上面的大家不一定都对并行编程很感兴趣，所以省略了大部分纠结与调试的故事，只留下了好玩的部分。</p><p>比赛要和其他选手比拼技术，所以算是 “竞技”。因为经常睡不好，考验身体素质，所以也是某种很新的 “体育”。四舍五入 CPC 也是竞技体育。</p><h2 id="比赛简介"><a href="#比赛简介" class="headerlink" title="比赛简介"></a>比赛简介</h2><p>CPC 是 “国产 CPU 并行应用挑战赛” 的简称。赛制大概是，主办方给出一个程序，让选手在特定架构的机器上优化，最后谁的程序跑得快谁就赢了。</p><p>今年主办方给的机器是一台名叫 “神威·问海一号” 的超级计算机，它是 “神威·太湖之光” 的后继者，国产超级计算机的明星之一。关于超级计算机，大家简单地理解成 “在上面用某些华丽的技巧编程，写出来的程序可以跑得很快” 的奇特电脑就可以了。</p><p>遗憾地是，这个国产超级计算机的硬件设计有很多不足。整个问海一号的架构被我们称为 “硬件设计友好型架构” —— 硬件工程师设计时自己怎么偷懒怎么来，给软件工程师（嗨呀，这是我）造成了诸多限制，使得我们在这个架构上编程难度颇大。同时，问海一号的现象还比较反常识，许多指令的加速效果远远不如它们在 x86 上的等价物。</p><p>我愿称其为 <strong>超算原神</strong> 。</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><p>初赛的任务是优化一个大程序中的小部分，和我们平时做的东西挺像。</p><p>我负责的部分是数据划分。就是把一个巨大的矩阵，切成很多个小小矩阵，让我的队友们写的代码来做后续处理。它只要满足划分出的任务量尽可能负载均衡、队友使用我的划分结果足够方便、缓存十分友好、能够适应不同的数据规模大小、不带来额外的数据转换开销等等条件的基础上跑得足够快就好了。最后我就写了这么一个东西。</p><blockquote><p>“我什么都做得到！” —— 我，于七边形活动室，写完这部分代码之后</p></blockquote><p>初赛的代码全是用 C 和 C++ 写的，很友好。我能很轻松地把一部分模块抽出来放到 x86 的架构上优化，再把优化后的代码给缝到原来的项目里面。这样原来自己熟悉的 perf 等等工具链就都可以用了。相比性能分析工具都要自己写的神威架构，x86 简直是天堂。</p><p>比赛后期队友 P 同学发挥奇思妙想，参考 OpenGL 的双缓冲技术，设计了一组面向 DMA 操作的双缓冲数据结构与 API，成功地将数据传输的开销掩盖在了计算下面，获得了巨量的性能提升。堪称最有想象力的一集。</p><p>还有个非常欢乐的事情是，神威架构上的 512 位浮点 SIMD 加速比仅有 1.8x 左右。经过我的仔细思考，我觉得可能神威在实现 SIMD 的时候就是单纯地给前端解码加了条指令，后端实际还是逐个逐个元素计算的……相当于仅省略了解码开销。不知道是不是真的但是很符合我对神威的想像。</p><p>很遗憾，初赛到现在已经过了两个多月了，期间经历了期末考试、构造动画片电视台、升级重构 bot、研究跨平台包管理器、无聊的并行计算课、学 vscode、学习怎么逛街、配置全新网络文件系统、研究 AMD ROCm、打工以及最终暑假结束了也没找到女朋友等诸多好玩的事情，具体初赛时发生了什么我已经几乎忘光了（其实暑假做了什么我也几乎忘掉了，这个列表是参考 bash history 和 bot 聊天记录写出来的），只留下了印象最深的一点点事情。也许应该发展一下写日记的习惯……或者用 bot 代劳写日记的习惯。</p><h2 id="决赛"><a href="#决赛" class="headerlink" title="决赛"></a>决赛</h2><p>决赛的任务是优化一个巨大的 Fortran 项目，和我们平时做的东西一点也不像。</p><p>决赛刚刚开始的几天我恰好开始实习，就拿到了一份任务列表。拿着做了两三天发现自己要是想跟上任务表的进度，每天都会很累，回到酒店后根本就没啥精力和心情来搓 CPC 的傻逼 Fortran 代码。于是研究了一下换人的可能性。但是就在换人讨论的后一天上班时，无意间发现自己拿到的好像是一个月量的任务表，但是自己把它当成一周的量来做了。本来还以为是什么万恶扒皮公司压榨实习生的剧情，结果现在直接做上了做一休三的悠闲生活。因为突然多出了不少空闲时间，我就接着打 CPC 比赛了。</p><p>实习公司的网络管制很严格，要和它的防火墙斗智斗勇才能成功打洞连上比赛的集群。比赛开打的前几天，网络相关的知识猛增……</p><p>决赛集齐了 Fortran、神威、大项目 等多种我们的短板，所以游戏体验并不良好。大量时间被花在了无意义的代码调试上，欢乐的事情很少很少……每天最快乐的事情就是骂骂神威。</p><p>之前大家还是一直认为 “Machine is always right” 的，但是在神威上编了几个月程，遇到了一堆问题后，最后几天调试代码我都有点开始相信风水了。总之，在神威机器上编程的时候，遇到问题除了排查自己的代码中出现的问题外，还要排查编译器本身的选项、从核同步性等一系列本应由编译器开发人员和硬件设计人员给我们弄好的问题。烦烦烦。</p><h2 id="决赛现场"><a href="#决赛现场" class="headerlink" title="决赛现场"></a>决赛现场</h2><p>决赛的前一天半夜，队友突然发现比赛集群上的环境疑似被主办方重置了，导致大家的 git 被回滚到了旧版本，某些功能没法用。作为成熟稳重可靠万能的超算队前辈（嗨呀，突然发现参赛小队里只有一个勉强能算后辈，怎么回事呢），我就连夜给它重新装了一个。</p><p>现场照片：</p><p>决赛比较无聊，到后面有点垃圾时间的意味。于是……</p><blockquote><p>原神，启动！ —— 某不知名 P 同学</p><p>星铁，启动！ —— 某不知名 H 同学</p></blockquote><p>以及畅想讨论怎么把比赛现场的 NVidia 的计算卡偷走的时候及时发现后面路过的（名义上的）我们队的指导老师。</p><h2 id="神秘收获"><a href="#神秘收获" class="headerlink" title="神秘收获"></a>神秘收获</h2><p>感觉这次算是第一次遇到自己没法单刷的比赛，确定了自己并不是什么都做得到。之前因为比赛的工程量都比较小，想了想反正可以单刷就几乎没管过团队合作的事情。但是这次比赛拿到题时就知道这不太是一个人可以搞定的东西，再加上队长和队友都很积极，于是点了一些协作方面的技能。通过交流让四个人达成共识，并一起完成同一件事，感觉是某种很新的体验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPC-2023-简明总结&quot;&gt;&lt;a href=&quot;#CPC-2023-简明总结&quot; class=&quot;headerlink&quot; title=&quot;CPC 2023 简明总结&quot;&gt;&lt;/a&gt;CPC 2023 简明总结&lt;/h1&gt;&lt;p&gt;记录我印象里的 CPC 2023 的大概流程。想着 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些书上不怎么讲的编译器优化方法</title>
    <link href="https://jyi2ya.github.io/2023/10/01/note/lto-plo/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/note/lto-plo/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些书上不怎么讲的编译器优化方法"><a href="#一些书上不怎么讲的编译器优化方法" class="headerlink" title="一些书上不怎么讲的编译器优化方法"></a>一些书上不怎么讲的编译器优化方法</h1><h2 id="内容预览"><a href="#内容预览" class="headerlink" title="内容预览"></a>内容预览</h2><p><strong>注意：理论上，要搞清楚编译器所做的工作，我们应该从词法分析讲到中间代码生成，再从汇编生成讲到链接。但是因为大家都学过编译原理，从词法分析到汇编的一系列内容大家都已经学烂了。为了保证大家都有兴趣，我们把大部分能从《编译原理》和《现代编译原理：C语言描述》里面找到的内容都删掉了（其实是根本没写）！</strong></p><p>整个分享将会讲述一些书上没有的优化点和优化方法。还会介绍大家平时写的语言用得很少，但是 Jvavavava 和别的一些脚本语言用得很多神奇玩意 —— JIT。</p><p>一些名词在 LLVM 和 MSVC 中有不同的称呼，会在标题使用 LLVM 的叫法，并且在正文给出 MSVC 的叫法，方便大家 RTFM。</p><h2 id="JIT-Just-In-Time-Compilation"><a href="#JIT-Just-In-Time-Compilation" class="headerlink" title="JIT - Just In Time Compilation"></a>JIT - Just In Time Compilation</h2><p>即时编译器。作用大概是把代码一边执行一边翻译成机器语言，从而用一些编译的代价，换取之后相关代码执行更快的利益。工作量主要在于确定何时进行翻译，优化到什么程度，以及优化 JIT 本身的速度。</p><p>本来按照历史的进程，应该先讲 AOT 部分的，但是有些重要概念在 JIT 里面讲比较方便，所以就调换了一下顺序。</p><h3 id="单层编译器"><a href="#单层编译器" class="headerlink" title="单层编译器"></a>单层编译器</h3><p>没有解释器，所有代码执行之前都会被编译一次，然后直接执行二进制代码。</p><p>可以类比一下 <a href="https://www.bellard.org/tcc/">Tiny C Compiler</a> 的 <code>tcc -run</code> 命令。这个命令声称能直接执行 C 语言代码。但是实际上是先把 C 编译一遍，存到内存里再执行的。因为现在单层结构的 JIT 实际上几乎没有了，所以也没找到什么好玩的例子。</p><p>优点：</p><ul><li>好写。要求不高的话，造一个飞快的编译器就可以了</li></ul><p>缺点：</p><ul><li>不优化会很慢。如果你的编译器真的一点也不优化的话，你会发现你编译到二进制的语言会和 Java 打得 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html">有来有回</a></li><li>更糟的是，因为每次执行代码时 JIT 编译器都要运行一遍，就注定这个编译器不可能牺牲编译时间来换取更多的优化。</li></ul><h3 id="解释器-编译器"><a href="#解释器-编译器" class="headerlink" title="解释器 + 编译器"></a>解释器 + 编译器</h3><p>典型的是 Java 的虚拟机 —— HotSpot VM。听名字就知道，HotSpot VM 和性能热点有关。事实也是如此。</p><p>HotSpot VM 运行时会首先对程序解释执行，接着分析程序性能热点。并将热点部分编译。</p><p>通常，编译器分为很多层，对应不同的优化等级。一段代码在执行过程中会被反复编译，程序越热的部分，得到的优化会越多。</p><p>这么看来，我们自己也是某种神秘 JIT。写代码时先用 perf&#x2F;vtune 之类的东西查出性能热点，然后再优化跑得多的部分……</p><blockquote><p>为什么针对热点优化：<a href="https://en.wikipedia.org/wiki/Amdahl's_law">阿姆达尔定律</a></p></blockquote><h3 id="FDO-Feadback-Directed-Optimization"><a href="#FDO-Feadback-Directed-Optimization" class="headerlink" title="FDO - Feadback-Directed Optimization"></a>FDO - Feadback-Directed Optimization</h3><p>之前我们已经知道了多层的 JIT 会分析运行的代码执行的情况，以确定何时对代码进行优化。</p><p>我们只收集 “代码在过去一段时间内运行次数” 这一个信息，就可以较好地确定代码需要的优化程度。但是我们在运行时对程序进行分析时，往往能得到更多的信息。比如，程序在某个分支失败的概率等等。而这些信息往往是无法在源代码中体现出来的。我们能不能利用这些信息来对代码做进一步的优化呢？</p><p>这就是 FDO 的思路：利用代码运行时的收集的数据来优化代码。</p><p>在微软的文档里通常叫 PGO，Profile-Guided Optimization</p><p>很容易想到，借助 FDO 我们可以实现这几个神奇优化：</p><ul><li>内联高频执行的函数</li><li>寄存器分配优化</li><li>条件跳转优化</li></ul><p>还有一些不那么容易想到的优化：</p><ul><li>虚函数调用优化：发现某个 virtual call 总是调一个函数，就加一组条件判断 + 直接调用来优化</li></ul><p>同时，由于 FDO 是根据代码运行的实际数据来优化，所以它会更加容易适应实际数据的模式。这比 AOT 编译对着源代码瞎猜好多了……</p><p>JIT 中的 FDO 通常也分为两种，分别是：</p><ul><li>Sample-Based FDO：工作方式类似 <code>perf(1)</code>，原理是采样</li><li>Instrumentation-based FDO：工作方式类似 <code>gprof(1)</code>，原理是插桩</li></ul><p>因为平时没写什么带 JIT 的脚本语言，所以这部分暂时没有例子。如果有人知道的话欢迎补充一些。</p><h2 id="AOT-Ahead-Of-Time-Compilation"><a href="#AOT-Ahead-Of-Time-Compilation" class="headerlink" title="AOT - Ahead Of Time Compilation"></a>AOT - Ahead Of Time Compilation</h2><p>AOT，即 Aheaed Of Time。顾名思义，就是把程序提前编译好，整成二进制&#x2F;字节码啥的，然后需要用的时候直接执行。在这期间，编译器 <strong>通常</strong> 会消耗大量计算资源对代码进行大量优化。不同 pass 的优化贯穿了整个代码生成的过程。</p><h3 id="LTO-Link-Time-Optimization"><a href="#LTO-Link-Time-Optimization" class="headerlink" title="LTO - Link-Time Optimization"></a>LTO - Link-Time Optimization</h3><p>微软把这个叫 <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2015/february/compilers-what-every-programmer-should-know-about-compiler-optimizations">LTCG</a>，怪。</p><p>链接时优化，发生在汇编器之后，生成可执行文件之前。</p><p>大致思想是，在链接时把目标文件都读进内存里，接着把这些东西看成一个整体，进行激进的优化。</p><p>优点：</p><ul><li>跨文件的函数内联、常量传播、死代码消除等等</li><li>跨编程语言优化，比如，可以优化 C 和 Rust 混写的代码。</li><li>可实现相同代码的折叠与消除（听起来有点像 zip 压缩的感觉？）</li></ul><p>缺点：</p><ul><li>冲浪时发现 <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36912.pdf">有个文章</a> 说相同函数的折叠在涉及到函数指针的比较操作时可能不安全，至于为什么我暂且蒙在鼓里……</li><li>非常慢。我在编译 rust 代码时如果开了 <code>lto = &quot;fat&quot;</code>，要在链接那里等好久。</li></ul><p>对策：</p><ul><li>将内存中的巨大二进制代码分块，并行进行 LTO。不过并行度越高，同一个优化线程所看到的代码就越少，优化机会也就越少。所以这里还是涉及到编译速度和编译质量折衷的问题……</li></ul><p>具体到实现上的话，<a href="https://gcc.gnu.org/onlinedocs/gccint/LTO-Overview.html">GCC</a> 和 <a href="https://llvm.org/docs/LinkTimeOptimization.html">LLVM</a> 不约而同（约了也说不定，反正大家都你偷我的我偷你的……）地选择了 bitcode 的形式。也就是说，开启 LTO 相关的编译选项后，生成的目标文件中将不再是机器码，而是编译器自己的 bitcode。至于为什么这样设计，官方文档说如果换用其他方案会产生工程复杂性等诸多问题，因为我没写过链接器，不太知道咋回事，所以也暂且蒙在鼓里。</p><p>同时，GCC 和 LLVM 各自又把 LTO 的过程划分成了好几个阶段，并不是一趟跑完的（所以才这么慢啊）。</p><h3 id="FDO-Feadback-Directed-Optimization-1"><a href="#FDO-Feadback-Directed-Optimization-1" class="headerlink" title="FDO - Feadback-Directed Optimization"></a>FDO - Feadback-Directed Optimization</h3><p>上面讲 JIT 的时候就已经提到了 FDO，我们知道 FDO 是需要依靠代码运行时的信息来决定优化方式。这种优化似乎天生是适合 JIT 的，因为 JIT 在解释执行代码的时候就能自然地拿到很多关于程序运行情况的信息。</p><p>如果我们说，在 AOT 编译里面也能做 FDO 呢？</p><p>以 <a href="https://learn.microsoft.com/en-us/cpp/build/profile-guided-optimizations?view=msvc-170">MSVC</a> 为例（他们会把这个操作叫 PGO），它的大概流程是：</p><ol><li>先用一些魔法参数编译出一个可执行文件</li><li>运行这个可执行文件几次（称为 train run），它会自动收集运行信息并且写到某个文件里</li><li>另一些魔法参数，使编译器参考之前收集到的信息来编译出最终的可执行文件</li></ol><p>LLVM 好像也有类似物，叫做 <a href="https://github.com/google/autofdo">autofdo</a>，由 Google 开发，有几页 <a href="https://www.llvm.org/devmtg/2013-04/novillo-slides.pdf">简单介绍</a>。但是我还没看完，懒狗程度令人感叹。</p><p>之前我们提到，JIT 里面的 FDO 有很多优化，比如：</p><ul><li>内联高频执行的函数</li><li>寄存器分配优化</li><li>条件跳转优化</li></ul><p>相比之下， AOT 的 FDO 还能做出更多神奇的优化，比如：</p><ul><li>基本块优化：可以把经常执行的一些基本块放到同一个 page 里面</li><li>死代码隔离：把多次 train run 都没有使用的代码放一个独立的 section 里面，如果它们没真的没被运行，就不用给它们分配 page 了！</li><li>错误处理代码隔离：同死代码隔离。</li></ul><p>然而，在 AOT 上应用 FDO 还会有很多不可忽略的缺点：</p><ul><li>编译模型十分复杂</li><li>大大增加编译时间</li><li>如果 train run 时使用的数据不够典型，甚至可能做出负优化</li></ul><p>所以，目前 FDO 技术暂时还没有在 AOT 里面被广泛使用。</p><h3 id="BOLT-Binary-Optimization-and-Layout-Tool"><a href="#BOLT-Binary-Optimization-and-Layout-Tool" class="headerlink" title="BOLT - Binary Optimization and Layout Tool"></a>BOLT - Binary Optimization and Layout Tool</h3><p>似乎是 LLVM 专属的，目前还没有在别的地方找到类似物。仓库在 <a href="https://github.com/llvm/llvm-project/tree/main/bolt">这里</a>。</p><p>和 FDO 很像，也是基于运行时的信息来优化代码。不过和 FDO 不同之处在于，FDO 在产出可执行文件时需要根据收集到信息重新链接程序，而 BOLT 则是直接基于已有的可执行程序重建控制流等信息，接着调整整个程序布局。</p><p>由于不需要重新链接，BOLT 甚至可以对没有源码的库或者可执行程序优化。</p><p>非常科技。</p><h2 id="吔我-AI-啦"><a href="#吔我-AI-啦" class="headerlink" title="吔我 AI 啦"></a>吔我 AI 啦</h2><p>能不能用 AI 来帮我优化代码啊妈的</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><blockquote><p>快过年了，不要再讨论什么 AOT JIT 之类了。你写的各种离谱的 pass 和不知道怎么优化出来的代码回到家并不能给你带来任何实质性作用，朋友们兜里掏出一大把钱吃喝玩乐，你默默的在家里用各种晦涩难懂的语言和各种奇奇怪怪的技术优化出来的代码压根不对。亲戚朋友吃饭问你收获了什么你说我差点把图着色 RA 写出来了，亲戚们懵逼了，你还在心里默默嘲笑他们，笑他们不懂 Register Allocation，不懂 Local 和 Global 的区别，不懂 IR 除了 SSA 还能做 SoN，不懂一个 SSA 可以被你们玩出Hashed SSA，formal SSA，也笑他们根本不知道你的编译器的diagnosis都弄了个 TTY 真彩色 但实际上根本没人在意。你父母的同事都在说自己的子女一年的收获，儿子买了个房，女儿买了个车，姑娘升职加薪了，你的父母默默无言，说我的儿子整了个小电脑，天天黑框敲个烂代码天天对着笑，一天折腾那个 Lit 和 GTEST，破电脑开起来嗡嗡响，家里的电表转的是越来越快了，头上的头发越来越少了，人也越来越魔怔了</p></blockquote><p>编译器越来越强了，以往很多的技巧（比如著名的 <a href="https://en.wikipedia.org/wiki/Duff%27s_device">Duff’s Device</a>）正在随着编译技术的发展而成为历史。</p><p>任何编译器做优化都需要足够的信息，比如，有了控制流图就可以做可达性分析，多了运行时得到的信息又可以做 FDO。</p><p>而人对自己正在面对的问题，知道的信息总会是比编译器多的。所以，你要把你知道的东西或显式（比如，<code>likely()</code> 和 <code>unlikely</code>）或隐式（比如，不用向后跳的 <code>goto</code> 以免破坏可规约性）地告诉编译器，让编译器来帮你完成复杂而繁琐的优化。</p><p>快进到和编译器双向奔赴然后结婚😋😋</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些书上不怎么讲的编译器优化方法&quot;&gt;&lt;a href=&quot;#一些书上不怎么讲的编译器优化方法&quot; class=&quot;headerlink&quot; title=&quot;一些书上不怎么讲的编译器优化方法&quot;&gt;&lt;/a&gt;一些书上不怎么讲的编译器优化方法&lt;/h1&gt;&lt;h2 id=&quot;内容预览&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Page/Buffer Cache 是什么？</title>
    <link href="https://jyi2ya.github.io/2023/10/01/note/page-buffer-cache/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/note/page-buffer-cache/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<p>Page&#x2F;Buffer Cache 是什么？</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><ul><li><p>试图最小化磁盘 IO</p></li><li><p>本质上是一堆内存页面</p></li></ul><blockquote><p>内存页面（Page）：一小段连续内存，是操作系统管理内存的最小单位</p></blockquote><ul><li>包含了很多最近访问过的<strong>文件的内容</strong><ul><li>意思是不包括 inode、目录等东西！</li></ul></li></ul><blockquote><p>对于 inode 和目录来说，他们的 page cache 的类似物分别叫做 inode cache 和 directory entry cache。其中 directory entry cache 又由 inode cache 组织而来。</p></blockquote><ul><li><p>用途广泛，用于 file-backed mmap、buffered io，甚至 swap。</p></li><li><p>需要文件系统支持</p></li></ul><h2 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a>Buffer Cache</h2><ul><li><p>试图最小化磁盘 IO</p></li><li><p>本质上是内存里的一堆块</p></li></ul><blockquote><p>块：操作系统对磁盘操作的基本单位，在 Linux 中要求大小为 2 的整数次幂，且比 sector 大，比 page 小</p></blockquote><blockquote><p>sector：磁盘读写数据的最小单位，由磁盘决定。</p></blockquote><ul><li><p>包含了最近访问过的块</p></li><li><p>用途不多，基本上只用来加速块设备</p></li></ul><blockquote><p>块设备（Block Device）：支持随机读写的设备。典型的比如磁盘。</p></blockquote><ul><li>不需要文件系统</li></ul><blockquote><p>比如，文件系统的 superblock 一般会躺在 buffer cache 里面</p></blockquote><h2 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h2><p>可以参考下图（从 <a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix01/full_papers/kroeger/kroeger_html/node8.html">usenix</a> 上面偷的）：</p><p><img src="/overview.png" alt="overview.png"></p><blockquote><p><strong>考古时间</strong></p><p>为什么 page cache 是一堆内存页面，而 buffer cache 是一堆块呢？</p><p>最开始 Linux 上面只有 buffer cache，此时 buffer cache 仅仅用于加速 buffered io 操作，向上与 read&#x2F;write 交互，向下与磁盘交互。所以 buffer cache 设计成一堆块是很合适的。</p><p>page cache 则是为了支持 mmap，在 2.2 版本中引入的。由于它和内存关系比较紧密，所以设计成一堆内存页的形式。不过此时 buffered io 仍然只与 buffer cache 交互，不与 page cache 交互。要等两个 cache 合并之后才会出现大家所熟知的「调用 read&#x2F;write 之后会写 page cache，过一会儿由操作系统把脏页写回磁盘」这种模式。</p></blockquote><h1 id="一些比较复杂的东西"><a href="#一些比较复杂的东西" class="headerlink" title="一些比较复杂的东西"></a>一些比较复杂的东西</h1><h2 id="page-cache-和-buffer-cache-其实是一个东西？"><a href="#page-cache-和-buffer-cache-其实是一个东西？" class="headerlink" title="page cache 和 buffer cache 其实是一个东西？"></a>page cache 和 buffer cache 其实是一个东西？</h2><p>虽然逻辑上还是可以将他们分为两个东西，但是其实两者只是同一套数据的不同组织方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------+</span><br><span class="line">| page                                  |</span><br><span class="line">|+-------+ +--------+ +--------++------+|</span><br><span class="line">||buffer1| | buffer2| |buffer3 ||buffer||</span><br><span class="line">||       | |        | |        ||  4   ||</span><br><span class="line">|+-------+ +--------+ +--------++------+|</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure><p>（没找到合适的图所以画了个）</p><p>每个 buffer 可以通过 <code>buffer_head</code> 结构体中的 <code>b_page</code> 字段获取自己对应的 page，同时 page 也可以通过 <code>page</code> 结构体中的 <code>buffers</code> 字段来得到自己所拥有的一组 buffer。</p><h2 id="既然-page-cache-与-buffer-cache-合并了……"><a href="#既然-page-cache-与-buffer-cache-合并了……" class="headerlink" title="既然 page cache 与 buffer cache 合并了……"></a>既然 page cache 与 buffer cache 合并了……</h2><p>那如果我在 A 进程对 <code>/dev/sda1</code> 上的一个文件 F 的一个连续区域做 shared mmap，再在 B 进程对 <code>/dev/sda</code> 本身做 shared mmap，两个进程映射的实际磁盘空间一致，那 A 进程与 B 进程能映射到同一个 page 吗？</p><p>答案是不行 :3。因为 A 进程的 page 是文件系统给的，而 B 进程得到的东西更像是一堆 buffer 组合成的 page。</p><p>此时数据组织大概是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------+  +---------------------------------------+</span><br><span class="line">| A page                                |  | B page                                |</span><br><span class="line">|                                       |  |                                       |</span><br><span class="line">|                                       |  |                                       |</span><br><span class="line">|    o         o          o           o |  |   o       o          o         o      |</span><br><span class="line">|    |         |          |           | |  |   |       |          |         |      |</span><br><span class="line">+----|---------|----------|-----------|-+  +---|-------+----------+---------+------+</span><br><span class="line">     v         v          v           v        |       |          |         |</span><br><span class="line"> +-------+ +--------+ +--------+   +------+    |       |          |         |</span><br><span class="line">`|buffer1| | buffer2| |buffer3 |   |buffer|    |       |          |         |</span><br><span class="line"> |       | |        | |        |   |  4   |    |       |          |         |</span><br><span class="line"> +---^---+ +---^----+ +---^----+   +--^---+    |       |          |         |</span><br><span class="line">     +---------+----------|-----------+--------+       |          |         |</span><br><span class="line">               +----------|-----------+----------------+          |         |</span><br><span class="line">                          +-----------+---------------------------+         |</span><br><span class="line">                                      +---------------------------+---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="一些好玩的接口"><a href="#一些好玩的接口" class="headerlink" title="一些好玩的接口"></a>一些好玩的接口</h1><h2 id="来点文件预读"><a href="#来点文件预读" class="headerlink" title="来点文件预读"></a>来点文件预读</h2><p>除了缓存已经读过&#x2F;写过的数据之外，猜测程序要读什么从而提前把它们读进 page cache 中，也能加快程序！</p><ul><li><p>posix_fadvise(2): <code>POSIX_FADV_SEQUENTIAL</code> 参数可以暗示内核自己将要顺序读文件。</p></li><li><p>madvise(2): <code>MADV_SEQUENTIAL</code> 参数可以暗示内核自己将顺序使用一些内存，配合 <code>mmap(2)</code> 使用。</p></li><li><p>readahead(2)：简单直接地告诉内核，偷偷多读一些东西（感觉这是个没用的屑调用……）。</p></li></ul><h2 id="掉落擦车"><a href="#掉落擦车" class="headerlink" title="掉落擦车"></a>掉落擦车</h2><p>可以通过 <code>/proc/sys/vm/drop_caches</code> 来告知内核扔掉一些 cache 数据。可以通过 <code>echo X &gt; /proc/sys/vm/drop_caches</code> 来使用。其中 X 的取值可以为 1, 2 或 3。当 X 为 1 时意思是让内核扔掉所有 page cache 里面的数据。2 和 3 代表什么，不知道 :3。</p><p>在测试一些 io-bounded 的程序时，为了防止 page cache 对测量结果造成干扰，可以在测试前运行一下。</p><h1 id="未解之谜"><a href="#未解之谜" class="headerlink" title="未解之谜"></a>未解之谜</h1><p>发现自己还是不太看得懂 <code>free(1)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            13Gi       4.4Gi       3.2Gi       135Mi       6.5Gi       9.1Gi</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Page&amp;#x2F;Buffer Cache 是什么？&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;Page-Cache&quot;&gt;&lt;a href=&quot;#Page-Cac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Perf 笔记</title>
    <link href="https://jyi2ya.github.io/2023/10/01/note/perf/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/note/perf/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Perf-笔记"><a href="#Perf-笔记" class="headerlink" title="Perf 笔记"></a>Perf 笔记</h1><p>环境 <code>Linux Syameimaru-Aya 5.17.0-2-amd64 #1 SMP PREEMPT Debian 5.17.6-1 (2022-05-11) x86_64 GNU/Linux</code>。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>首先安装 <code>linux-perf</code> 软件包，获得 <code>perf(1)</code> 应用程序。</p><p>接着运行 <code>perf</code>，发现报了奇怪的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">19:56 Syameimaru-Aya ~/sr/la/hpc/perf</span><br><span class="line">0 perf record -a ./a.out</span><br><span class="line">Error:</span><br><span class="line">Access to performance monitoring and observability operations is limited.</span><br><span class="line">Consider adjusting /proc/sys/kernel/perf_event_paranoid setting to open</span><br><span class="line">access to performance monitoring and observability operations for processes</span><br><span class="line">without CAP_PERFMON, CAP_SYS_PTRACE or CAP_SYS_ADMIN Linux capability.</span><br><span class="line">More information can be found at &#x27;Perf events and tool security&#x27; document:</span><br><span class="line">https://www.kernel.org/doc/html/latest/admin-guide/perf-security.html</span><br><span class="line">perf_event_paranoid setting is 3:</span><br><span class="line">  -1: Allow use of (almost) all events by all users</span><br><span class="line">      Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK</span><br><span class="line">&gt;= 0: Disallow raw and ftrace function tracepoint access</span><br><span class="line">&gt;= 1: Disallow CPU event access</span><br><span class="line">&gt;= 2: Disallow kernel profiling</span><br><span class="line">To make the adjusted perf_event_paranoid setting permanent preserve it</span><br><span class="line">in /etc/sysctl.conf (e.g. kernel.perf_event_paranoid = &lt;setting&gt;)</span><br></pre></td></tr></table></figure><p>跟着报错提示里面提到的文档 <a href="https://www.kernel.org/doc/html/latest/admin-guide/perf-security.html">Perf events and tool security</a> 看了一圈，大概知道问题出在 <code>perf</code> 的安全措施上。文档里说，随意使用 <code>perf</code> 可能允许人获得其他人正在运行的程序中的数据，不安全。我用的发行版就默认配置成所有人都不能使用 <code>perf</code> 了。</p><p>文档给了一种多用户时控制权限，只让特定的人使用 <code>perf</code> 的做法：首先将 <code>/usr/bin/perf</code> 用 <code>setcap(8)</code> 程序加上 <code>CAP_PERFMON</code> <code>CAP_SYS_PTRACE</code> 两个标签，使 <code>/usr/bin/perf</code> 能够正常使用（没有 <code>CAP_PERFMON</code> 标签的应用程序无法调用 <code>perf_event_open(2)</code> 函数）。接着新建个用户组，仅使在那个组里的用户拥有 <code>/usr/bin/perf</code> 的可执行权限。这样对于一个不允许使用 <code>perf</code> 的人来说，外面偷来的 <code>perf</code> 会因为没有 <code>CAP_PERFMON</code> 而无法使用，自带的 <code>/usr/bin/perf</code> 则没有执行权限。整个设置避免了未经许可的人使用 <code>perf</code> 程序。</p><p>因为我的笔记本电脑肯定只有我一个用户，所以我非常暴力地改了一发，在 <code>root</code> 权限下往 <code>/proc/sys/kernel/perf_event_paranoid</code> 文件里写了个 <code>-1</code>。接着在 <code>/etc/sysctl.conf</code> 里加入一行 <code>kernel.perf_event_paranoid = -1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Syameimaru-Aya:~/tmp# echo -1 &gt; /proc/sys/kernel/perf_event_paranoid</span><br><span class="line">root@Syameimaru-Aya:~/tmp#</span><br></pre></td></tr></table></figure><p>接着 <code>perf</code> 就可以正常运行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">20:27 Syameimaru-Aya ~/sr/la/hpc/perf</span><br><span class="line">0 cat a.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; 10000000; ++i)</span><br><span class="line">        i + i;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">20:27 Syameimaru-Aya ~/sr/la/hpc/perf</span><br><span class="line">0 gcc -O0 a.c &amp;&amp; perf record -a ./a.out</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.877 MB perf.data (104 samples) ]</span><br></pre></td></tr></table></figure><h2 id="获得炫酷火焰图"><a href="#获得炫酷火焰图" class="headerlink" title="获得炫酷火焰图"></a>获得炫酷火焰图</h2><p>中午午睡的时候梦到生成火焰图要用命令 <code>perf script flamegraph</code>。于是试了一下，发现不行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20:29 Syameimaru-Aya ~/sr/la/hpc/perf</span><br><span class="line">0 perf script flamegraph</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">perf_event_attr:</span><br><span class="line">  size                             128</span><br><span class="line">  &#123; sample_period, sample_freq &#125;   4000</span><br><span class="line"></span><br><span class="line">... 超级长的输出 ...</span><br><span class="line"></span><br><span class="line">Flame Graph template /usr/share/d3-flame-graph/d3-flamegraph-base.html does not exist. Please install the js-d3-flame-graph (RPM) or libjs-d3-flame-graph (deb) package, specify an existing flame graph template (--template PATH) or another output format (--format FORMAT).</span><br></pre></td></tr></table></figure><p>啊报错说缺少包 <code>libjs-d3-flame-graph</code>。太良心了，连缺什么包都给提示好。显得我很笨的样子 :(。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20:33 Syameimaru-Aya ~/sr/la/hpc/perf</span><br><span class="line">0 i libjs-d3-flame-graph</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package libjs-d3-flame-graph</span><br></pre></td></tr></table></figure><p>提示说包不存在。用 <code>apt-file</code> 找了下报错信息中提到的关键文件 <code>/usr/share/d3-flame-graph/d3-flamegraph-base.html</code>，发现源里没有这个东西。不过在 <a href="pkgs.org">pkgs.org</a> 上找了下发现 <code>rpm</code> 的包到是有……怀疑开发都写报错信息的时候只是把红帽系打包的命名习惯改成了 <code>Debian</code> 系的，估计根本就没看有没有这个包吧！</p><p><img src="/pkgs.png" alt="怎么全是 rpm 包"></p><p>最后用 <code>alien(1p)</code> 把 <code>rpm</code> 转成 <code>deb</code> 装上。成功运行。</p><p><img src="/flame-graph.png" alt="超级酷炫的火焰图！"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Perf-笔记&quot;&gt;&lt;a href=&quot;#Perf-笔记&quot; class=&quot;headerlink&quot; title=&quot;Perf 笔记&quot;&gt;&lt;/a&gt;Perf 笔记&lt;/h1&gt;&lt;p&gt;环境 &lt;code&gt;Linux Syameimaru-Aya 5.17.0-2-amd64 #1 SM</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>对集群上 df 和 du 命令显示结果不一致的排查记录</title>
    <link href="https://jyi2ya.github.io/2023/10/01/note/running-process-constantly-consume-disk-space/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/note/running-process-constantly-consume-disk-space/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对集群上-df-和-du-命令显示结果不一致的排查记录"><a href="#对集群上-df-和-du-命令显示结果不一致的排查记录" class="headerlink" title="对集群上 df 和 du 命令显示结果不一致的排查记录"></a>对集群上 df 和 du 命令显示结果不一致的排查记录</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在集群上跑作业，然后把磁盘空间吃掉了。把占用空间很大的文件删掉后，<code>du /home</code> 命令的结果显示磁盘占用已经回到了正常水平，但是 <code>df -h</code> 显示，<code>/home</code> 所在分区的磁盘占用率还是 100%，也不能新建和修改文件。</p><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><h3 id="不会是把文件系统弄坏了吧！"><a href="#不会是把文件系统弄坏了吧！" class="headerlink" title="不会是把文件系统弄坏了吧！"></a>不会是把文件系统弄坏了吧！</h3><p>仔细想了想好像不可能，因为平时都是用普通用户的身份工作的……不太可能搞出影响文件系统的操作。</p><h3 id="有些人的小文件太多，把-inode-给用光了！"><a href="#有些人的小文件太多，把-inode-给用光了！" class="headerlink" title="有些人的小文件太多，把 inode 给用光了！"></a>有些人的小文件太多，把 inode 给用光了！</h3><p>看起来有可能，但是回想下很久很久以前自己做赛博仓鼠的时候遇到的问题，就会发现两个问题表现完全不一样。</p><p>很久很久以前，赛博鼠鼠 jyi 试图往自己的鼠鼠洞里塞图片，发现没有磁盘空间了！他 <code>df</code> 了下，发现硬盘空间还有很多，但是新建文件就是会出错。他又试了试往已有的文件后面追加写入一些东西，好像可以成功。他觉得非常奇怪，“凭什么磁盘有空间，但是就是不让我放东西呢？”</p><p>用一种比较笨蛋的方法来看 <code>ext&#123;2,3,4&#125;</code> 文件系统，就知道文件系统中，一个文件需要 1 个 inode 和许多许多 block。其中，inode 用来存放文件的元数据，block 用来存放文件本身。由于 block 数量一般多于 inode 的数量（block 的数量少于 inode 的数量有啥用啊……），所以可能会出现 inode 耗尽，而 block 有剩余的情况。在这种情况下，无法新建文件，却可以修改文件。</p><p>因为赛博鼠鼠 jyi 非常菜，所以他与电脑搏斗了一番后才想起关于 inode 的知识。他 <code>df -i</code> 了一下，发现自己要存放图片的文件系统的 inode 已经用光了。最后他把一些图片打包成 sfs，再挂载到<del>世界树</del>目录树上，从而在原本的文件系统里回收了一些 inode，终于解决了这个问题。</p><p>回到集群上来，为什么这个表现和集群上遇到的状况完全不一样呢？因为经过检查发现，集群上显示 <code>df -i</code> 不是 100%，<code>df -h</code> 显示的使用率是 100%；而很久很久以前和自己的电脑搏斗时，<code>df -i</code> 显示的使用率是 100%，<code>df -h</code> 则是比 100 小不少的数字。</p><p>这说明集群上很可能不是很多小文件把 inode 用光的问题，更可能是巨大文件很简单地把 block 用光的问题。</p><h3 id="有一些邪恶文件藏在了黑暗角落里！"><a href="#有一些邪恶文件藏在了黑暗角落里！" class="headerlink" title="有一些邪恶文件藏在了黑暗角落里！"></a>有一些邪恶文件藏在了黑暗角落里！</h3><p>Linux 下面是可以往非空目录上挂载文件系统的，挂载后原目录里有的文件将会被遮盖掉。这些文件显然会被 <code>df</code> 统计，但是不会被 <code>du</code> 统计。</p><p>显然，最简单的方法就是把根目录之外的所有目录卸载，然后跑一下 <code>df</code> 和 <code>du</code>。然而，现在要操作的是运行中的系统（也许还有同学在上面跑神秘程序，那种中断了会遭遇线下真人快打的），不能这么粗暴地处理……</p><p>最后我找了个 tmpfs <code>/run/mnt</code>（因为根目录下没法新建文件夹做挂载点了），然后 <code>mount --bind / /run/mnt</code>。接着进 <code>/run/mnt</code> 一看，发现 <code>df</code> 和 <code>du</code> 的结果仍然不同！仍然是 <code>du</code> 很少一点，<code>df</code> 巨大无比的结果。</p><h2 id="破案"><a href="#破案" class="headerlink" title="破案"></a>破案</h2><p>正在自闭时，突然想起来，好像学文件系统时在懵懵懂懂的时候学到了 Linux 下 inode 结构体里，有关 <code>i_count</code> 和 <code>i_nlink</code> 的知识。其中，<code>i_count</code> 代表当前有多少个文件描述符引用了这个文件，<code>i_nlink</code> 代表这个文件在文件系统里有多少个硬链接。当且仅当 <code>i_count</code> 和 <code>i_nlink</code> 都为零时，这个 inode 和她所持有的 block 才被会释放。有没有这种可能，一个神秘邪恶，吃光了磁盘的巨大文件，它的 <code>i_nlink</code> 是 0 同时 <code>i_count</code> 非零，这样它不会被递归查看文件名的 <code>du</code> 找到，但是能被统计 block 的 <code>df</code> 给检查到呢？</p><p>于是使用 <code>lsof | grep deleted</code> 一查，果然有一堆坏比 Perl 程序，打开了巨大文件没关。文件的所有者是我，大小有 780G。考虑到集群上好像只有我写 Perl，所以主谋是谁应该不言自明了……</p><h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>使用天火圣裁发动了一次牛逼的攻击……其实是 <code>ps -u jyi</code>，把自己所有的进程，不管好比还是坏比都干掉了。然后 <code>df</code> 了几次，看着可用空间逐渐上涨。</p><p>问题最终解决了，可喜可贺可喜可贺。另外给好朋友说这个事时，还听说在 “进程打开了文件，但是文件不小心删掉了” 这种情况下，在进程关闭之前，可以去 <code>/proc/X/fd/Y</code> 下面把文件找回来。其中 <code>X</code> 是进程 pid，<code>Y</code> 是软链接，名字就是文件描述符，目标是被打开的文件，用 <code>cat</code> 命令就可以把文件给找回来。利用的也是 inode 释放的机制。</p><p>总之，Linux 真神奇啊 :3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对集群上-df-和-du-命令显示结果不一致的排查记录&quot;&gt;&lt;a href=&quot;#对集群上-df-和-du-命令显示结果不一致的排查记录&quot; class=&quot;headerlink&quot; title=&quot;对集群上 df 和 du 命令显示结果不一致的排查记录&quot;&gt;&lt;/a&gt;对集群上 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>shell 初始化</title>
    <link href="https://jyi2ya.github.io/2023/10/01/note/shell-init/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/note/shell-init/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-初始化"><a href="#shell-初始化" class="headerlink" title="shell 初始化"></a>shell 初始化</h1><p>众所周知，shell 初始化是一坨巨大的不祥之物。但是如果不了解初始化的过程的话，可能会在编写各种 rc、crontab 时被折磨。所以分享让大家试吃一下。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>login shell 是个比较古老的概念，指由 logind 验证用户身份后，便提供一个 login shell 供用户工作。这个 shell 的特殊意义在于，它和用户的会话紧紧绑定在一起，在它开始运行前与它结束运行后都会往 <code>/var/log/wtmp</code> 写入用户的登录记录。除了它以外，所有的被用户手动运行的 shell 都被视作普通的应用程序。</p><p>因为大家现在都在 tty7 用各种基于 X 的登录管理器，它们验证用户身份后会提供一个桌面环境，所以 login shell 的概念没啥用了。但是它的一些历史遗留问题还是可能给大家带来困惑。</p><p>生成一个 login shell 有两种方法：</p><ol><li>在 shell 后面加上 <code>-l</code> 参数，比如 <code>bash -l</code>。</li></ol><p>比如，这是一个 login shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 bash -l</span><br><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 logout</span><br></pre></td></tr></table></figure><p>而这不是一个 login shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 bash</span><br><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 logout</span><br><span class="line">bash: logout: not login shell: use `exit&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>让 shell 的 <code>argv[0]</code> 以 <code>-</code> 开头。</li></ol><p>我们在通过 ssh 远程登录，或者从 ttyN 用 logind 登录时都可以获得 login shell。显然 logind 和 ssh 不应当对 shell 的参数做出假设（即不能假设自己即将运行的程序有一个 <code>-l</code> 参数）。所以他们用改 <code>argv[0]</code> 的方式来通知 shell。</p><p>sshd 是这么干的的 <code>ssh/session.c</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we have no command, execute the shell.  In this case, the shell</span></span><br><span class="line"><span class="comment"> * name to be passed in argv[0] is preceded by &#x27;-&#x27; to indicate that</span></span><br><span class="line"><span class="comment"> * this is a login shell.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>logind 也是这么干的（在 ttyN 里面试试这些东西）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Debian GNU/Linux bookworm/sid Syameimaru-Aya tty2</span><br><span class="line">Syameimaru-Aya login: jyi</span><br><span class="line">Password:</span><br><span class="line">Linux Syameimaru-Aya 5.19.0-2-amd64 #1 SMP PREEMPT_DYNAMIC Debian 5.19.11-1 (2022-09-24) x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Fri Sep 30 03:06:30 CST 2022 on tty2</span><br><span class="line">03:34 Syameimaru-Aya ~/tmp</span><br><span class="line">0 echo $0</span><br><span class="line">-bash</span><br></pre></td></tr></table></figure><h3 id="interactive-shell"><a href="#interactive-shell" class="headerlink" title="interactive shell"></a>interactive shell</h3><p>区分 interactive 与 non-interactive 的意义在于，让 shell 在给人类使用时与执行脚本时表现出不同的行为。</p><p>要求标准输入和标准输出都指向终端（用 <code>isatty</code> 系统调用确定）。仅在 interactive shell 里面会打印提示符，同时启用行编辑和 job control 特性，对人类十分友好！</p><p>这也解释了为啥用 <code>nc -l -p 2333 -e /bin/bash</code> 搞的丐版远程登录非常难用，因为这不是 interactive shell，没有方便的编辑特性。也能解释为啥 <code>echo echo hello | bash</code> 不会输出提示符而是直接输出命令结果，因为这不是 interactive shell，不会输出提示符。</p><p>当然，也可以用 <code>-i</code> 选项暴力启动交互模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">03:42 Syameimaru-Aya ~</span><br><span class="line">0 echo echo hello | bash -i</span><br><span class="line">    03:43 Syameimaru-Aya ~</span><br><span class="line">    0 echo hello</span><br><span class="line">    hello</span><br><span class="line">    03:43 Syameimaru-Aya ~</span><br><span class="line">    0 exit</span><br><span class="line">03:43 Syameimaru-Aya ~</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>（为了分辨命令的输出，输出部分往右缩进了一些）。</p><p>此时 shell 会像正常一样输出提示符，读取输出并且执行。</p><h2 id="不同的组合读取配置文件的区别"><a href="#不同的组合读取配置文件的区别" class="headerlink" title="不同的组合读取配置文件的区别"></a>不同的组合读取配置文件的区别</h2><p>以 bash 为例：</p><p>login：首先是 <code>/etc/profile</code>，接着是 <code>/etc/profile.d/*</code>，最后是 <code>~/.bash_profile</code> <code>~/.bash_login</code> <code>~/.profile</code> 三者按顺序检查，读取第一个可读的文件。（注意没有 <code>~/.bashrc</code>）在 shell 退出时，还会读取 <code>~/.bash_logout</code>。<br>non-login：不会读取任何配置。<br>interactive：依次读取 <code>/etc/bash.bashrc</code> <code>~/.bashrc</code>。<br>non-interactive：不会读取任何配置。</p><p>一般情况下，shell 启动时读取的配置是上列之一，并且 login 优先于 interactive。比如，如果 shell 以 login + interactive 的方式启动，则会读取 <code>/etc/profile</code>、<code>/etc/profile.d/*</code>、<code>~/.bash_profile</code>或<code>~/.bash_login</code>或<code>~/.profile</code>，但是并不会考虑 <code>/etc/bash.bashrc</code> 和 <code>~/.bashrc</code>，即使这是一个 interactive shell。</p><p>有个仅用于 bash 的例外是，当其以 non-login 且 non-interactive 的方式启动时，它会检查名为 <code>BASH_ENV</code> 的环境变量。如果变量值所表示的文件存在，则会读取该文件作为配置。</p><h2 id="这套神秘机制造成的麻烦"><a href="#这套神秘机制造成的麻烦" class="headerlink" title="这套神秘机制造成的麻烦"></a>这套神秘机制造成的麻烦</h2><h3 id="bashrc-与-bash-profile-之间的互动"><a href="#bashrc-与-bash-profile-之间的互动" class="headerlink" title="~/.bashrc 与 ~/.bash_profile 之间的互动"></a><code>~/.bashrc</code> 与 <code>~/.bash_profile</code> 之间的互动</h3><ol><li>login shell 不会读取 <code>~/.bashrc</code>，这使得 login shell 不能读取一些配置，很难用。为了解决这个问题，人们决定在 <code>~/.bash_profile</code> 里引用 <code>~/.bashrc</code></li><li>一些人会在 <code>~/.bashrc</code> 里对命令加入一些保护措施，比如 <code>alias rm=&#39;rm -I --preseve-root&#39;</code>，使得在同时删除三个以上文件时需要确认才能删除，另外，有些人可能会拿垃圾桶代替 <code>rm</code>。</li><li>一些脚本会以 login 的方式执行（通常是运行得非常早的脚本，甚至不能从父进程里继承 <code>PATH</code>），以保证自己能读取 <code>/etc/profile</code>，得到正确的环境变量。</li></ol><p>当这三点齐聚时，会发生什么呢？</p><ol><li>安装软件包时，本来应该被彻底删除的临时文件被不明不白地扔进了垃圾箱里，占用不知道多少的空间。</li><li>即使用了 <code>-y</code> 参数来避免安装时的用户输出，仍然有可能因为 <code>rm -I</code> 等命令而需要等待输入。这对一些后台执行的脚本（比如定时自动更新）来说是非常坏的，因为很可能没有用户会来输入一个 <code>y</code>。</li></ol><p>为了解决这个问题，只好在 <code>~/.bashrc</code> 前面加上这一句看起来很像魔法咒语的指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ $- == *i* ]] || <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>……使得 bash 在读取 <code>~/.bashrc</code> 当配置文件时，如果是非交互终端则立即停止读取。</p><h3 id="crond-找不到命令，但是自己在终端里操作时又有"><a href="#crond-找不到命令，但是自己在终端里操作时又有" class="headerlink" title="crond 找不到命令，但是自己在终端里操作时又有"></a>crond 找不到命令，但是自己在终端里操作时又有</h3><p>为了方便描述，把这个命令叫作 lolcat</p><ol><li>有些人喜欢把 lolcat 放在 <code>~/.local/bin/</code> 里</li><li>有些人写 crontab 时喜欢用 lolcat（？）</li><li>他在 <code>~/.bashrc</code> 里面将 <code>~/.local/bin/</code> 加入到 <code>PATH</code> 中</li><li>crond 运行 shell 时为 non-interactive + non-login 模式</li></ol><p>会发生什么呢？</p><ol><li>当在终端里试图运行 lolcat 时，因为现有的是 interactive + non-login 模式，所以读取了 <code>~/.bashrc</code>，正确地设置了路径。</li><li>当在 crond 里运行 lolcat 时，因为是 non-interactive + non-login 模式，没有读取 <code>~/.bashrc</code>，<code>PATH</code> 里没有 <code>~/.local/bin</code>，找不到 lolcat</li></ol><p>所以在写 crontab 时，只好写 <code>bash -lc lolcat</code></p><p>不仅仅是 shell 脚本，C 中的 <code>system()</code>、Python 的 <code>os.system()</code> 以及更多类似物都会遇到这个问题。在终端里直接执行时，会从 bash 中继承 <code>PATH</code>，从而表现出正确的行为。而如果在 crond 内执行，则会出现找不到命令的问题。</p><h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><p>暂时没遇到……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shell-初始化&quot;&gt;&lt;a href=&quot;#shell-初始化&quot; class=&quot;headerlink&quot; title=&quot;shell 初始化&quot;&gt;&lt;/a&gt;shell 初始化&lt;/h1&gt;&lt;p&gt;众所周知，shell 初始化是一坨巨大的不祥之物。但是如果不了解初始化的过程的话，可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>urxvt 跑得比 alacritty 还快，为什么呢？</title>
    <link href="https://jyi2ya.github.io/2023/10/01/note/urxvt-jump-skip-scroll/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/note/urxvt-jump-skip-scroll/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="urxvt-跑得比-alacritty-还快，为什么呢？"><a href="#urxvt-跑得比-alacritty-还快，为什么呢？" class="headerlink" title="urxvt 跑得比 alacritty 还快，为什么呢？"></a>urxvt 跑得比 alacritty 还快，为什么呢？</h1><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>答案是 urxvt 并没有老老实实地绘制其内程序输出的每一个字符，而是通过一些非常取巧的方法，减少了屏幕渲染的内容数量。</p><p>具体来说，是用了以下两个优化：</p><ul><li>jump scroll：如果短时间内需要渲染很多行，那么 urxvt 仅会在收到的行能充满一屏时尝试刷新。</li><li>skip scroll：在 jump scroll 的基础上，限制刷新率为 60 Hz。</li></ul><p>开启这两个优化之后，urxvt 收到的很多内容实际上都被直接扔进历史记录里了，根本没在屏幕上出现过。同时，因为人的眼睛是非常低速的设备，所以即使这些内容没有在屏幕上出现，也不会影响使用体验。</p><p>如果禁用掉这些小优化，urxvt 的速度大概仅是 alacritty 的 1&#x2F;2 到 1&#x2F;3。</p><h2 id="alacritty-与-urxvt-的简介"><a href="#alacritty-与-urxvt-的简介" class="headerlink" title="alacritty 与 urxvt 的简介"></a>alacritty 与 urxvt 的简介</h2><p>urxvt 本身是个二十多年前的老东西，使用了很多奇怪的 X 特性。配置文件和 xterm 一样非常奇怪，可能是 Xorg 给世界留下的遗产之一……使用 C 和 C++ 编写，用 Perl 扩展。rxvt 的可扩展性很强，对标准支持也很好，各种 corner case 处理相对比较完善。</p><p>alacritty 是个很新的项目，号称要成为最快的终端。使用超级炒作语言 rust 开发，并且实现了 GPU 加速。他们一度声称自己是 “Fastest Terminal Emulator in Existence（现存最快终端）”。但是在 2020 年末的 <a href="https://github.com/alacritty/alacritty/commit/3d7b16d4b0d867268c315f421904f3a2dc81a72d">一次提交</a> 中不知道为什么他们换了说法，甚至连大家炒作时最爱的 “Blazing Fast” 也干没了。可能是开发者开发地表最速终端的梦想在现实里撞车了。非常快乐，大家快去围观。总之，相比项目早期的自述，现在的自述温和了很多。</p><p>两个都是非常好的终端。我之前是在 Windows 下用 alacritty，在 Linux 下用 urxvt。</p><h2 id="为什么需要关注终端速度"><a href="#为什么需要关注终端速度" class="headerlink" title="为什么需要关注终端速度"></a>为什么需要关注终端速度</h2><p>……其实意义也不是很大，因为大家在输出内容太长的时候都会 <code>| less</code> 一下，用 pager 分页来看，终端速度对使用体验的影响很小。</p><p>但是既然速度是个能比的项目，那总会有人抱着一种宝可梦对决的心态来研究两个终端谁快谁慢，这也促进了这篇水帖的诞生！</p><h2 id="urxvt-的小优化相关代码"><a href="#urxvt-的小优化相关代码" class="headerlink" title="urxvt 的小优化相关代码"></a>urxvt 的小优化相关代码</h2><p>摘自 urxvt 代码仓库 <code>src/command.C</code> 的第 2267 行。</p><pre><code>if (ecb_unlikely (ch == C0_LF || str &gt;= eol))  &#123;    if (ch == C0_LF)      nlines++;    refresh_count++;    if (!option (Opt_jumpScroll) || refresh_count &gt;= nrow - 1)      &#123;        refresh_count = 0;        if (!option (Opt_skipScroll) || ev_time () &gt; ev::now () + 1. / 60.)          &#123;            refreshnow = true;            ch = NOCHAR;            break;          &#125;      &#125;</code></pre><p>大概就是它用一堆错综复杂的条件变量实现了上面提到的小优化，整段代码唯一的注释的是这样的：</p><pre><code>/* * If there have been a lot of new lines, then update the screen * What the heck we&#39;ll cheat and only refresh less than every page-full. * if skipScroll is enabled. */</code></pre><p>摆了。这啥 GNU-style 的神秘老代码看得我头疼……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;urxvt-跑得比-alacritty-还快，为什么呢？&quot;&gt;&lt;a href=&quot;#urxvt-跑得比-alacritty-还快，为什么呢？&quot; class=&quot;headerlink&quot; title=&quot;urxvt 跑得比 alacritty 还快，为什么呢？&quot;&gt;&lt;/a&gt;ur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>markdown 中使用图片但是不使用图床</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/blog-image/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/blog-image/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-中使用图片但是不使用图床"><a href="#markdown-中使用图片但是不使用图床" class="headerlink" title="markdown 中使用图片但是不使用图床"></a>markdown 中使用图片但是不使用图床</h1><p>起因是写博客要插入图片，但是懒得上传图片到图床。经过一番尝试后发现可以把图片 base64 编码后放进 markdown 语法中本应该放图片 url 的位置，直接将图片插进 markdown 文件里。</p><p>显然我们需要找出 markdown 中的图片。为了减少图片大小，还需要缩放和压缩。为了偷懒想找找有没有相关的项目可以实现功能。只找到了 <a href="https://gitee.com/hujingnb/markdownImage">markdownImage</a>。但是这个图片压缩好像是调用一些网站的 api 来完成相关功能的，还有免费次数限制，并且并不提供图片缩放功能。感觉和需求出入有点大……</p><p>最后我写了个便利脚本来完成这项任务，需要机器上安装了 imagemagick、base64 和 tr。</p><p>（这个脚本问题还是比较多，比如没有区分代码块里格式类似图片链接的部分和真正的图片链接，某些情况，比如 markdown 教程估计会锅掉。但是总之还是能用的嘛）</p><p>会从标准输入和命令行文件中读取内容，处理后输出到标准输出。（在后面接一个 clip 剪贴板程序就可以直接准备发布到博客园啦）</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env perl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> v5.<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">process_image</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$_ = <span class="keyword">shift</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.gif$/</span>) &#123;</span><br><span class="line"><span class="string">&quot;data:image/gif;base64,&quot;</span> .</span><br><span class="line"><span class="string">qx &#123;</span></span><br><span class="line"><span class="string">convert -fuzz 15% -layers Optimize \Q$_\E - | base64 | tr -d &#x27;\n&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="string">&quot;data:image/jpeg;base64,&quot;</span> .</span><br><span class="line"><span class="string">qx &#123;</span></span><br><span class="line"><span class="string">convert -resize \Q1280x960&gt;\E -strip -quality 75% \Q$_\E jpeg:- | base64 | tr -d &#x27;\n&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">defined</span>(<span class="keyword">my</span> $line = &lt;&gt;)) &#123;</span><br><span class="line"><span class="keyword">for</span> ($line =~ <span class="regexp">/!\[[^\]]*\]\([^)]*\)/g</span>) &#123;</span><br><span class="line"><span class="keyword">my</span> ($mark, $desc, $file) = <span class="regexp">/(!\[([^\]]*)\]\(([^)]*)\))/</span>;</span><br><span class="line">$file = process_image $file;</span><br><span class="line">$line =~ <span class="regexp">s/\Q$mark\E/![$desc]($file)/</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> $line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;markdown-中使用图片但是不使用图床&quot;&gt;&lt;a href=&quot;#markdown-中使用图片但是不使用图床&quot; class=&quot;headerlink&quot; title=&quot;markdown 中使用图片但是不使用图床&quot;&gt;&lt;/a&gt;markdown 中使用图片但是不使用图床&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>用盲文字符来在终端画黑白图像</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/canvas/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/canvas/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用盲文字符来在终端画黑白图像"><a href="#用盲文字符来在终端画黑白图像" class="headerlink" title="用盲文字符来在终端画黑白图像"></a>用盲文字符来在终端画黑白图像</h1><h2 id="食用提示"><a href="#食用提示" class="headerlink" title="食用提示"></a>食用提示</h2><p>如果这篇文章在您的设备上显示很多方框，或许是字体出了问题。请确保自己使用的字体可以正常显示盲文。</p><p>在我的设备上，无论怎么操作都无法使 urxvt （rxvt ， xterm ） 表现出我想要的样子。因此在不建议您进行实验时使用 urxvt （rxvt ， xterm ） 。</p><h2 id="想法来源"><a href="#想法来源" class="headerlink" title="想法来源"></a>想法来源</h2><p>有一天发现盲文就是一堆像素点，就想着用盲文文字在终端画图。</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lsp7f3e4.png" alt="show1.png"><br><img src="https://cdn.luogu.com.cn/upload/image_hosting/1oy9pwhi.png" alt="show2.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">⠀⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏</span><br><span class="line">⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟</span><br><span class="line">⠠⠡⠢⠣⠤⠥⠦⠧⠨⠩⠪⠫⠬⠭⠮⠯</span><br><span class="line">⠰⠱⠲⠳⠴⠵⠶⠷⠸⠹⠺⠻⠼⠽⠾⠿</span><br><span class="line">⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏</span><br><span class="line">⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟</span><br><span class="line">⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯</span><br><span class="line">⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿</span><br><span class="line">⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏</span><br><span class="line">⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟</span><br><span class="line">⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯</span><br><span class="line">⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿</span><br><span class="line">⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏</span><br><span class="line">⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟</span><br><span class="line">⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯</span><br><span class="line">⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿</span><br></pre></td></tr></table></figure><p>这是 UTF-8 中的盲文字符。共有 256 个。每个盲文字符都由数个点组成。点最多的盲文字符（右下角）有 8 个点，它看起来像个实心黑框框；点最少的盲文字符有 0 个点（左上角），虽然它看上去像个空格，但它真的和空格不是一个东西。</p><p>稍微观察可以发现，一个盲文字符可以当成 4x2 的小形位图使用，如果能够良好组织，使盲文字符按某种方式排列，就可以拼出大一些的位图。</p><p>不同的 4x2 位图共有 2^8 &#x3D; 256 个，而不同的盲文字符正好也有 256 个。这意味着盲文字符和 4x2 的位图之间有着一一对应的关系。为了方便盲文与位图的与相转化，我们需要设计一种编码方案。</p><p>上面列出的表显然是经过良好组织的，可以发现盲文字符的排布很有规律。找规律的过程略去不提，这里仅说编码方案。经过以下操作后，可以保证盲文字符和其对应的 4x2 位图有相同的编号：</p><p>盲文：将上表中的盲文从上到下，从左到右依次编号 0 到 255 。</p><p>位图：考虑搞一张权值表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  8</span><br><span class="line">2  16</span><br><span class="line">4  32</span><br><span class="line">64 128</span><br></pre></td></tr></table></figure><p>将表中所有对应位图黑色位置的权值加起来，得到的和即为位图的编号。</p><p>例如，字符 “⢫” ，其编号为 171 ，其位图为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p>和权值表 py 后得到 1 + 8 + 2 + 32 + 128 &#x3D; 171 ，和期待结果一致。</p><p>使用这个方法，可以将 4x2 的小位图和它所对应的盲文字符的编号对应起来。于是，我们就可以在终端画图了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先对盲文字符打表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *magic_table[] = &#123;</span><br><span class="line"><span class="string">&quot;⠀&quot;</span>, <span class="string">&quot;⠁&quot;</span>, <span class="string">&quot;⠂&quot;</span>, <span class="string">&quot;⠃&quot;</span>, <span class="string">&quot;⠄&quot;</span>, <span class="string">&quot;⠅&quot;</span>, <span class="string">&quot;⠆&quot;</span>, <span class="string">&quot;⠇&quot;</span>, <span class="string">&quot;⠈&quot;</span>, <span class="string">&quot;⠉&quot;</span>, <span class="string">&quot;⠊&quot;</span>, <span class="string">&quot;⠋&quot;</span>, <span class="string">&quot;⠌&quot;</span>, <span class="string">&quot;⠍&quot;</span>, <span class="string">&quot;⠎&quot;</span>, <span class="string">&quot;⠏&quot;</span>,</span><br><span class="line"><span class="string">&quot;⠐&quot;</span>, <span class="string">&quot;⠑&quot;</span>, <span class="string">&quot;⠒&quot;</span>, <span class="string">&quot;⠓&quot;</span>, <span class="string">&quot;⠔&quot;</span>, <span class="string">&quot;⠕&quot;</span>, <span class="string">&quot;⠖&quot;</span>, <span class="string">&quot;⠗&quot;</span>, <span class="string">&quot;⠘&quot;</span>, <span class="string">&quot;⠙&quot;</span>, <span class="string">&quot;⠚&quot;</span>, <span class="string">&quot;⠛&quot;</span>, <span class="string">&quot;⠜&quot;</span>, <span class="string">&quot;⠝&quot;</span>, <span class="string">&quot;⠞&quot;</span>, <span class="string">&quot;⠟&quot;</span>,</span><br><span class="line"><span class="string">&quot;⠠&quot;</span>, <span class="string">&quot;⠡&quot;</span>, <span class="string">&quot;⠢&quot;</span>, <span class="string">&quot;⠣&quot;</span>, <span class="string">&quot;⠤&quot;</span>, <span class="string">&quot;⠥&quot;</span>, <span class="string">&quot;⠦&quot;</span>, <span class="string">&quot;⠧&quot;</span>, <span class="string">&quot;⠨&quot;</span>, <span class="string">&quot;⠩&quot;</span>, <span class="string">&quot;⠪&quot;</span>, <span class="string">&quot;⠫&quot;</span>, <span class="string">&quot;⠬&quot;</span>, <span class="string">&quot;⠭&quot;</span>, <span class="string">&quot;⠮&quot;</span>, <span class="string">&quot;⠯&quot;</span>,</span><br><span class="line"><span class="string">&quot;⠰&quot;</span>, <span class="string">&quot;⠱&quot;</span>, <span class="string">&quot;⠲&quot;</span>, <span class="string">&quot;⠳&quot;</span>, <span class="string">&quot;⠴&quot;</span>, <span class="string">&quot;⠵&quot;</span>, <span class="string">&quot;⠶&quot;</span>, <span class="string">&quot;⠷&quot;</span>, <span class="string">&quot;⠸&quot;</span>, <span class="string">&quot;⠹&quot;</span>, <span class="string">&quot;⠺&quot;</span>, <span class="string">&quot;⠻&quot;</span>, <span class="string">&quot;⠼&quot;</span>, <span class="string">&quot;⠽&quot;</span>, <span class="string">&quot;⠾&quot;</span>, <span class="string">&quot;⠿&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;⡀&quot;</span>, <span class="string">&quot;⡁&quot;</span>, <span class="string">&quot;⡂&quot;</span>, <span class="string">&quot;⡃&quot;</span>, <span class="string">&quot;⡄&quot;</span>, <span class="string">&quot;⡅&quot;</span>, <span class="string">&quot;⡆&quot;</span>, <span class="string">&quot;⡇&quot;</span>, <span class="string">&quot;⡈&quot;</span>, <span class="string">&quot;⡉&quot;</span>, <span class="string">&quot;⡊&quot;</span>, <span class="string">&quot;⡋&quot;</span>, <span class="string">&quot;⡌&quot;</span>, <span class="string">&quot;⡍&quot;</span>, <span class="string">&quot;⡎&quot;</span>, <span class="string">&quot;⡏&quot;</span>,</span><br><span class="line"><span class="string">&quot;⡐&quot;</span>, <span class="string">&quot;⡑&quot;</span>, <span class="string">&quot;⡒&quot;</span>, <span class="string">&quot;⡓&quot;</span>, <span class="string">&quot;⡔&quot;</span>, <span class="string">&quot;⡕&quot;</span>, <span class="string">&quot;⡖&quot;</span>, <span class="string">&quot;⡗&quot;</span>, <span class="string">&quot;⡘&quot;</span>, <span class="string">&quot;⡙&quot;</span>, <span class="string">&quot;⡚&quot;</span>, <span class="string">&quot;⡛&quot;</span>, <span class="string">&quot;⡜&quot;</span>, <span class="string">&quot;⡝&quot;</span>, <span class="string">&quot;⡞&quot;</span>, <span class="string">&quot;⡟&quot;</span>,</span><br><span class="line"><span class="string">&quot;⡠&quot;</span>, <span class="string">&quot;⡡&quot;</span>, <span class="string">&quot;⡢&quot;</span>, <span class="string">&quot;⡣&quot;</span>, <span class="string">&quot;⡤&quot;</span>, <span class="string">&quot;⡥&quot;</span>, <span class="string">&quot;⡦&quot;</span>, <span class="string">&quot;⡧&quot;</span>, <span class="string">&quot;⡨&quot;</span>, <span class="string">&quot;⡩&quot;</span>, <span class="string">&quot;⡪&quot;</span>, <span class="string">&quot;⡫&quot;</span>, <span class="string">&quot;⡬&quot;</span>, <span class="string">&quot;⡭&quot;</span>, <span class="string">&quot;⡮&quot;</span>, <span class="string">&quot;⡯&quot;</span>,</span><br><span class="line"><span class="string">&quot;⡰&quot;</span>, <span class="string">&quot;⡱&quot;</span>, <span class="string">&quot;⡲&quot;</span>, <span class="string">&quot;⡳&quot;</span>, <span class="string">&quot;⡴&quot;</span>, <span class="string">&quot;⡵&quot;</span>, <span class="string">&quot;⡶&quot;</span>, <span class="string">&quot;⡷&quot;</span>, <span class="string">&quot;⡸&quot;</span>, <span class="string">&quot;⡹&quot;</span>, <span class="string">&quot;⡺&quot;</span>, <span class="string">&quot;⡻&quot;</span>, <span class="string">&quot;⡼&quot;</span>, <span class="string">&quot;⡽&quot;</span>, <span class="string">&quot;⡾&quot;</span>, <span class="string">&quot;⡿&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;⢀&quot;</span>, <span class="string">&quot;⢁&quot;</span>, <span class="string">&quot;⢂&quot;</span>, <span class="string">&quot;⢃&quot;</span>, <span class="string">&quot;⢄&quot;</span>, <span class="string">&quot;⢅&quot;</span>, <span class="string">&quot;⢆&quot;</span>, <span class="string">&quot;⢇&quot;</span>, <span class="string">&quot;⢈&quot;</span>, <span class="string">&quot;⢉&quot;</span>, <span class="string">&quot;⢊&quot;</span>, <span class="string">&quot;⢋&quot;</span>, <span class="string">&quot;⢌&quot;</span>, <span class="string">&quot;⢍&quot;</span>, <span class="string">&quot;⢎&quot;</span>, <span class="string">&quot;⢏&quot;</span>,</span><br><span class="line"><span class="string">&quot;⢐&quot;</span>, <span class="string">&quot;⢑&quot;</span>, <span class="string">&quot;⢒&quot;</span>, <span class="string">&quot;⢓&quot;</span>, <span class="string">&quot;⢔&quot;</span>, <span class="string">&quot;⢕&quot;</span>, <span class="string">&quot;⢖&quot;</span>, <span class="string">&quot;⢗&quot;</span>, <span class="string">&quot;⢘&quot;</span>, <span class="string">&quot;⢙&quot;</span>, <span class="string">&quot;⢚&quot;</span>, <span class="string">&quot;⢛&quot;</span>, <span class="string">&quot;⢜&quot;</span>, <span class="string">&quot;⢝&quot;</span>, <span class="string">&quot;⢞&quot;</span>, <span class="string">&quot;⢟&quot;</span>,</span><br><span class="line"><span class="string">&quot;⢠&quot;</span>, <span class="string">&quot;⢡&quot;</span>, <span class="string">&quot;⢢&quot;</span>, <span class="string">&quot;⢣&quot;</span>, <span class="string">&quot;⢤&quot;</span>, <span class="string">&quot;⢥&quot;</span>, <span class="string">&quot;⢦&quot;</span>, <span class="string">&quot;⢧&quot;</span>, <span class="string">&quot;⢨&quot;</span>, <span class="string">&quot;⢩&quot;</span>, <span class="string">&quot;⢪&quot;</span>, <span class="string">&quot;⢫&quot;</span>, <span class="string">&quot;⢬&quot;</span>, <span class="string">&quot;⢭&quot;</span>, <span class="string">&quot;⢮&quot;</span>, <span class="string">&quot;⢯&quot;</span>,</span><br><span class="line"><span class="string">&quot;⢰&quot;</span>, <span class="string">&quot;⢱&quot;</span>, <span class="string">&quot;⢲&quot;</span>, <span class="string">&quot;⢳&quot;</span>, <span class="string">&quot;⢴&quot;</span>, <span class="string">&quot;⢵&quot;</span>, <span class="string">&quot;⢶&quot;</span>, <span class="string">&quot;⢷&quot;</span>, <span class="string">&quot;⢸&quot;</span>, <span class="string">&quot;⢹&quot;</span>, <span class="string">&quot;⢺&quot;</span>, <span class="string">&quot;⢻&quot;</span>, <span class="string">&quot;⢼&quot;</span>, <span class="string">&quot;⢽&quot;</span>, <span class="string">&quot;⢾&quot;</span>, <span class="string">&quot;⢿&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;⣀&quot;</span>, <span class="string">&quot;⣁&quot;</span>, <span class="string">&quot;⣂&quot;</span>, <span class="string">&quot;⣃&quot;</span>, <span class="string">&quot;⣄&quot;</span>, <span class="string">&quot;⣅&quot;</span>, <span class="string">&quot;⣆&quot;</span>, <span class="string">&quot;⣇&quot;</span>, <span class="string">&quot;⣈&quot;</span>, <span class="string">&quot;⣉&quot;</span>, <span class="string">&quot;⣊&quot;</span>, <span class="string">&quot;⣋&quot;</span>, <span class="string">&quot;⣌&quot;</span>, <span class="string">&quot;⣍&quot;</span>, <span class="string">&quot;⣎&quot;</span>, <span class="string">&quot;⣏&quot;</span>,</span><br><span class="line"><span class="string">&quot;⣐&quot;</span>, <span class="string">&quot;⣑&quot;</span>, <span class="string">&quot;⣒&quot;</span>, <span class="string">&quot;⣓&quot;</span>, <span class="string">&quot;⣔&quot;</span>, <span class="string">&quot;⣕&quot;</span>, <span class="string">&quot;⣖&quot;</span>, <span class="string">&quot;⣗&quot;</span>, <span class="string">&quot;⣘&quot;</span>, <span class="string">&quot;⣙&quot;</span>, <span class="string">&quot;⣚&quot;</span>, <span class="string">&quot;⣛&quot;</span>, <span class="string">&quot;⣜&quot;</span>, <span class="string">&quot;⣝&quot;</span>, <span class="string">&quot;⣞&quot;</span>, <span class="string">&quot;⣟&quot;</span>,</span><br><span class="line"><span class="string">&quot;⣠&quot;</span>, <span class="string">&quot;⣡&quot;</span>, <span class="string">&quot;⣢&quot;</span>, <span class="string">&quot;⣣&quot;</span>, <span class="string">&quot;⣤&quot;</span>, <span class="string">&quot;⣥&quot;</span>, <span class="string">&quot;⣦&quot;</span>, <span class="string">&quot;⣧&quot;</span>, <span class="string">&quot;⣨&quot;</span>, <span class="string">&quot;⣩&quot;</span>, <span class="string">&quot;⣪&quot;</span>, <span class="string">&quot;⣫&quot;</span>, <span class="string">&quot;⣬&quot;</span>, <span class="string">&quot;⣭&quot;</span>, <span class="string">&quot;⣮&quot;</span>, <span class="string">&quot;⣯&quot;</span>,</span><br><span class="line"><span class="string">&quot;⣰&quot;</span>, <span class="string">&quot;⣱&quot;</span>, <span class="string">&quot;⣲&quot;</span>, <span class="string">&quot;⣳&quot;</span>, <span class="string">&quot;⣴&quot;</span>, <span class="string">&quot;⣵&quot;</span>, <span class="string">&quot;⣶&quot;</span>, <span class="string">&quot;⣷&quot;</span>, <span class="string">&quot;⣸&quot;</span>, <span class="string">&quot;⣹&quot;</span>, <span class="string">&quot;⣺&quot;</span>, <span class="string">&quot;⣻&quot;</span>, <span class="string">&quot;⣼&quot;</span>, <span class="string">&quot;⣽&quot;</span>, <span class="string">&quot;⣾&quot;</span>, <span class="string">&quot;⣿&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着实现 canvas 结构体。这里用 <code>unsigned char</code> 数组当成 <code>bool</code> 数组使用。日后优化时，可以用 bitmap 节省空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">canvas</span> &#123;</span></span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="type">void</span> *buf;</span><br><span class="line">&#125; canvas;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">canvas_init</span><span class="params">(canvas *p, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line">width = ((width - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">height = ((height - <span class="number">1</span>) / <span class="number">4</span> + <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">p-&gt;width = width;</span><br><span class="line">p-&gt;height = height;</span><br><span class="line">p-&gt;buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) * width * height);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;buf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canvas_clear</span><span class="params">(canvas p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p.buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现画像素点和打印功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">canvas_draw</span><span class="params">(canvas p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> (*)[p.width])p.buf)[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canvas_erase</span><span class="params">(canvas p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> (*)[p.width])p.buf)[y][x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">canvas_test</span><span class="params">(canvas p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">char</span> (*)[p.width])p.buf)[y][x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canvas_print</span><span class="params">(canvas p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, k, l;</span><br><span class="line"><span class="keyword">for</span> (i = p.height; i &gt; <span class="number">0</span>; i -= <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; p.width; j += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &gt;= <span class="number">0</span>; --l)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">3</span>; k &gt;= <span class="number">1</span>; --k)</span><br><span class="line">id = (id &lt;&lt; <span class="number">1</span>) | canvas_test(p, j + l, i - k);</span><br><span class="line"><span class="keyword">if</span> (canvas_test(p, j, i - <span class="number">4</span>))</span><br><span class="line">id += <span class="number">64</span>;</span><br><span class="line"><span class="keyword">if</span> (canvas_test(p, j + <span class="number">1</span>, i - <span class="number">4</span>))</span><br><span class="line">id += <span class="number">128</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, magic_table[id]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现完成。以下是函数功能与参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int canvas_init(canvas *p, int width, int height); 将 p 初始化为宽 width 高 height 的画布</span><br><span class="line">void canvas_clear(canvas p); 销毁画布 p</span><br><span class="line">void canvas_draw(canvas p, int x, int y); 在 p 的 (x, y) 位置画上一个像素点</span><br><span class="line">void canvas_erase(canvas p, int x, int y); 擦除 p 中 (x, y) 位置上的像素点</span><br><span class="line">int canvas_test(canvas p, int x, int y); 返回 p 中 (x, y) 上是否已经画过</span><br><span class="line">void canvas_print(canvas p); 打印 p</span><br></pre></td></tr></table></figure><h2 id="实现示例中的效果"><a href="#实现示例中的效果" class="headerlink" title="实现示例中的效果"></a>实现示例中的效果</h2><p>用 ImageMagick 的 convert 命令将图片文件转为只有 2 种颜色的 xpm 文件，写个傻瓜 xpm 解析器，配合上面的代码简单处理即可得到示例中的效果。傻瓜解析器的代码见：<a href="https://www.luogu.org/paste/npaqkp89">doxpm.c</a> 。</p><p>在本机上，实现示例效果的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ convert -colors 2 sample.png a.xpm</span><br><span class="line">$ gcc doxpm.c -o doxpm</span><br><span class="line">$ ./doxpm</span><br><span class="line">$ <span class="comment"># 如果需要彩色的话：</span></span><br><span class="line">$ ./doxpm | lolcat</span><br></pre></td></tr></table></figure><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>代码仅被用来说明想法，并没有想写成一个可用的库。所以码风略快糙猛请多包涵。</p><p>感谢 zrz_orz 同学教我在洛谷日报上投稿，并提出大量修改意见。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用盲文字符来在终端画黑白图像&quot;&gt;&lt;a href=&quot;#用盲文字符来在终端画黑白图像&quot; class=&quot;headerlink&quot; title=&quot;用盲文字符来在终端画黑白图像&quot;&gt;&lt;/a&gt;用盲文字符来在终端画黑白图像&lt;/h1&gt;&lt;h2 id=&quot;食用提示&quot;&gt;&lt;a href=&quot;#食</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 complete-alias 补全 bash 别名的参数</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/complete-alias/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/complete-alias/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-complete-alias-补全-bash-别名的参数"><a href="#使用-complete-alias-补全-bash-别名的参数" class="headerlink" title="使用 complete-alias 补全 bash 别名的参数"></a>使用 complete-alias 补全 bash 别名的参数</h1><h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>众所周知，bash 中有个很方便的功能，使用 <code>alias</code> 命令创建命令别名。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git</span></span><br><span class="line"><span class="built_in">alias</span> cg=<span class="string">&#x27;cd `git rev-parse --show-toplevel || echo .`&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gaA=<span class="string">&#x27;git add -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gad=<span class="string">&#x27;git add&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gbc=<span class="string">&#x27;git branch&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcm=<span class="string">&#x27;git commit&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gco=<span class="string">&#x27;git checkout&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gst=<span class="string">&#x27;git status&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcl=<span class="string">&#x27;git clone&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> glg=<span class="string">&#x27;git log --graph&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gmg=<span class="string">&#x27;git merge&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gdf=<span class="string">&#x27;git diff&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，如果我们输入 <code>gcl</code>，bash 就会认为我们输入的是 <code>git clone</code>。极大地减少了输入字母的数量。</p><h2 id="命令参数补全"><a href="#命令参数补全" class="headerlink" title="命令参数补全"></a>命令参数补全</h2><p>bash 还有另一个强大的功能，命令参数补全。这个命令参数补全不仅仅是补全当前目录下的文件，而是根据当前已经输入的命令和参数，猜测补全下一个参数。一般来说发行版都会提供大量写好的补全脚本，可以直接使用。</p><p>以 Debian 为例，安装 <code>bash-completion</code> 软件包后，在 <code>~/.bashrc</code> 中加上 <code>source /etc/bash_completion</code>。接着输入命令，连续按下两下 <code>tab</code> 键就可以触发补全功能（按下 <code>tab</code> 键的地方在下面用 <code>&lt;TAB&gt;</code> 表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% 19:50:08 (master) ~/sr/md/bl/note/complete-alias</span><br><span class="line">0 ls --h&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">--help                --hide-control-chars  --hyperlink</span><br><span class="line">--hide=               --human-readable</span><br></pre></td></tr></table></figure><p>虽然说没有 zsh 的好用就是啦。</p><h2 id="但是有一个小问题"><a href="#但是有一个小问题" class="headerlink" title="但是有一个小问题"></a>但是有一个小问题</h2><p>bash 的命令参数补全是根据命令名来确定的，举一个简单的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">_id</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> cur prev words cword</span><br><span class="line">    _init_completion || <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$cur</span> == -* ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> opts=$(_parse_help <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line">        [[ <span class="variable">$opts</span> ]] || opts=<span class="string">&quot;-G -g -u&quot;</span> <span class="comment"># POSIX fallback</span></span><br><span class="line">        COMPREPLY=($(compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="string">&quot;<span class="variable">$cur</span>&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        COMPREPLY=($(compgen -u <span class="string">&quot;<span class="variable">$cur</span>&quot;</span>))</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125; &amp;&amp;</span><br><span class="line">    complete -F _id <span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>这是从 <code>/usr/share/bash-completion/completions/id</code> 里面摘抄的补全相关代码。可以看到，代码里先实现了 shell 函数 <code>_id</code>，再用 <code>complete -F _id id</code> 来把 <code>id</code> 命令相关的补全和 <code>_id</code> 绑定在一起。即需要补全 <code>id</code> 命令的参数时，会用某种方式调用 <code>_id</code> 函数。</p><p>这样确实可以处理很多情况，但是对别名无效。比如我们运行 <code>alias gco=&#39;git checkout&#39;</code>，把 <code>gco</code> 作为 <code>git checkout</code> 的别名。当我们输入 <code>gco</code> 再按 <code>tab</code> 键时，因为没有绑定 <code>gco</code> 相关的补全函数，所以 bash 不知道如何补全，只能在后面接上文件名。</p><p>我们期待的行为应该是输入 <code>gco</code> 再按 <code>tab</code> 就和输入 <code>git checkout</code> 再按 <code>tab</code> 一样，可以补全出分支名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% 20:03:23 (master) ~/sr/md/bl/note/complete-alias</span><br><span class="line">0 git checkout&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">HEAD                 linux-csharp-build   master               ORIG_HEAD</span><br></pre></td></tr></table></figure><h2 id="小问题解决了"><a href="#小问题解决了" class="headerlink" title="小问题解决了"></a>小问题解决了</h2><p>之前肯定也有人遇到过一样的问题，并且造了相关的轮子。这儿有一个好用的：<a href="https://github.com/cykerway/complete-alias">complete-alias</a>。</p><p>我们只要把仓库里面 <code>complete_alias</code> 文件中的内容复制下来，贴到 <code>~/.bashrc</code> 尾巴上（有 1000 多行，有点野蛮。讲究的人可以把它放到某个目录里然后 <code>.bashrc</code> 里面用 <code>source</code> 命令处理？），再把最后一行 <code>#complete -F _complete_alias &quot;$&#123;!BASH_ALIASES[@]&#125;&quot;</code> 前面的井号 <code>#</code> 删掉就算配置完成。重新启动 bash 即可使用。</p><p>总而言之挺开箱即用的，配置不费劲。</p><p>效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% 20:14:27 (master) ~/sr/md/bl/note/complete-alias</span><br><span class="line">0 gco&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">HEAD                 linux-csharp-build   master               ORIG_HEAD</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-complete-alias-补全-bash-别名的参数&quot;&gt;&lt;a href=&quot;#使用-complete-alias-补全-bash-别名的参数&quot; class=&quot;headerlink&quot; title=&quot;使用 complete-alias 补全 bash 别名的参</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hyperfine 使用指南</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/hyperfine/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/hyperfine/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hyperfine-使用指南"><a href="#hyperfine-使用指南" class="headerlink" title="hyperfine 使用指南"></a>hyperfine 使用指南</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>测量程序运行耗时是一个常见的需求。</p><p>我们经常会调整自己编写的程序，来给程序加速。但是自己提出的加速计划，不一定会被<br>机器认可。比如，你觉得 <code>++i</code> 比 <code>i++</code> 更快并且花了两天时间把程序里所有的后缀全<br>改成了前缀，但是机器不管，她编译的时候直接把你的写法给扬掉了。这个时候再在 git<br>的提交信息里写 <code>perf: 优化 XX 部分性能</code> 就会显得非常滑稽。所以，我们经常需要对<br>程序性能测试来保证自己的优化是有效的。对程序性能测试的最常用的方法就是计时。</p><p>小时候幼儿园的老师经常教育我们，在 <a href="https://manpages.debian.org/buster/bash/bash.1.en.html">bash</a> 里面用 <code>time</code> 的命令就可以测量程序<br>运行的时间。这也是大家最常用的方法。但是我们都知道，<code>time</code> 是一个非常粗糙的工<br>具。用它测量程序性能时，总会遇到这么几个问题：</p><ul><li>测量出来的时间真的是准的吗？会不会受到系统波动的影响？</li><li>测量出来的时间有多可靠？该怎么知道测量误差？</li><li>我能比较轻松地对比两个或多个程序的性能吗？</li></ul><p>我们可以通过写一堆土制脚本来解决上述问题，但是与其费心写功能不全、漏洞百出的脚<br>本，还不如直接使用已有的趁手工具。</p><p><a href="https://github.com/sharkdp/hyperfine">hyperfine</a> 就是一个优秀的性能测试工具。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>根据 hyperfine 自己的 <a href="https://github.com/sharkdp/hyperfine/blob/master/README.md">介绍</a> ，hyperfine 拥有如下功能：</p><ul><li>多次测量并统计均值方差</li><li>支持任意 shell 命令</li><li>进度条和预估剩余时间</li><li>预热：正式测试之前先运行几次</li><li>测试之前执行指定命令（可用于清除缓存）</li><li>自动发现 cache 影响和系统性能波动影响</li><li>多种输出格式，支持 CSV、JSON、Markdown 等等</li><li>跨平台</li></ul><p>（注：hyperfine 的介绍是有 <a href="https://github.com/chinanf-boy/hyperfine-zh">中文翻译</a> 的，但是我看的时候它略微有些过时了。<br>希望有好心人来更新一下翻译）</p><p>它的使用截图如下：</p><p><img src="https://camo.githubusercontent.com/88a0cb35f42e02e28b0433d4b5e0029e52e723d8feb8df753e1ed06a5161db56/68747470733a2f2f692e696d6775722e636f6d2f7a31394f5978452e676966" alt="hyperfine"></p><p>个人评测：life-changing 的好东西，我现在没有 hyperfine 都不会测程序了。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>hyperfine 的使用方式非常符合直觉，命令行结构和选项设计得很好。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>hyperfine 是用 <a href="https://www.rust-lang.org/">rust</a> 写的（不打算去学一下？）。如果机器上有 rust 开发环境，<br>直接运行 <code>cargo install hyperfine</code> 即可完成安装。<a href="https://doc.rust-lang.org/cargo/">cargo</a> 是 rust 的编译系统<br>和依赖管理工具。</p><p>如果机器上没有 rust 开发环境，可以求助你的包管理器，或者从<br><a href="https://github.com/sharkdp/hyperfine/releases">hyperfine 在 Github 上的发布页面</a> 中，下载与自己的机器架构对应的二进制<br>文件。</p><h3 id="测试单个程序"><a href="#测试单个程序" class="headerlink" title="测试单个程序"></a>测试单个程序</h3><p>命令：</p><pre><code>hyperfine &#39;hexdump file&#39;</code></pre><p>结果：</p><pre><code>11:17 jyi-station ~/tmp/bgifile0 hyperfine &#39;hexdump test13.c&#39;Benchmark 1: hexdump test13.c  Time (mean ± σ):     385.0 ms ±   5.1 ms    [User: 383.0 ms, System: 2.1 ms]  Range (min … max):   381.6 ms … 398.9 ms    10 runs</code></pre><p>从结果可以看出，hyperfine 把程序运行了 10 次。测量出来平均耗时是 385 ms，误差<br>是 5.1 ms。运行的时候，hyperfine 把程序的所有输出重定向到了 <code>/dev/null</code> 里，所<br>以终端上没有多余的内容。</p><p>你看，我几乎什么都没做，只是把命令提供给 hyperfine，她就自动帮忙把所有东西都测<br>好了！</p><p>我们甚至无需检查误差是否过大，因为 hyperfine 会自动检测误差过大的情况，并且根<br>据程序运行时间的特征来猜测可能发生了什么问题，并给出一些建议。非常贴心。后面会<br>详细讨论这些细节。</p><h3 id="对比测试多个程序"><a href="#对比测试多个程序" class="headerlink" title="对比测试多个程序"></a>对比测试多个程序</h3><p>命令：</p><pre><code>hyperfine &#39;hexdump test13.c&#39; &#39;xxd test13.c&#39; &#39;xxd test14.c&#39;</code></pre><p>结果：</p><pre><code>11:24 jyi-station ~/tmp/bgifile0 hyperfine &#39;hexdump test13.c&#39; &#39;xxd test13.c&#39; &#39;xxd test14.c&#39;Benchmark 1: hexdump test13.c  Time (mean ± σ):     383.6 ms ±   1.9 ms    [User: 381.8 ms, System: 1.6 ms]  Range (min … max):   381.6 ms … 387.7 ms    10 runsBenchmark 2: xxd test13.c  Time (mean ± σ):      90.2 ms ±   1.0 ms    [User: 88.4 ms, System: 1.9 ms]  Range (min … max):    88.7 ms …  93.4 ms    32 runsBenchmark 3: xxd test14.c  Time (mean ± σ):     180.2 ms ±   2.8 ms    [User: 176.8 ms, System: 3.2 ms]  Range (min … max):   177.1 ms … 186.6 ms    16 runsSummary  &#39;xxd test13.c&#39; ran    2.00 ± 0.04 times faster than &#39;xxd test14.c&#39;    4.25 ± 0.05 times faster than &#39;hexdump test13.c&#39;</code></pre><p>在这个例子里，我们给了 hyperfine 三个参数，让她测量三个程序的耗时。hyperfine<br>首先输出了三个程序各自的运行结果，这部分和测试单个程序时的结果差不多。但是在报<br>告的最后，hyperfine 还额外给出了一些信息。她指出了跑的最快的程序（港记程序 :P）<br>，并且显示了其相对其他程序的加速比和误差。</p><p>我们一般测试程序时只需要关注最后的 “Summary” 一栏，知道哪个更快、快多少就可以<br>了。前面几行是和别人吵架时，给他们看测试结果让他们闭嘴时用的。</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p>对每个程序，hyperfine 会把它运行 10 次（运行次数有选项可以配置）。hyperfine 会<br>对运行时间计时，并且求出均值和标准差。</p><p>每次运行的时候，hyperfine 会运行一个 shell 来执行这些程序。比如，假定程序<br>是 <code>sleep 1</code>，那么 hyperfine 实际运行的是 <code>sh -c &#39;sleep 1&#39;</code>。这种用 shell 来运<br>行程序的行为，会导致程序运行时间测量结果偏大；但是如果不用 shell 来运行程序，<br>大家平时习惯的 <code>~/</code> 和 <code>*.txt</code> 这些便利缩写就不能用了，非常麻烦。</p><p>总之，这种使用 shell 来执行参数的设计，算是便利与准确之间的一种折衷。</p><p>为了使测量结果更精确，你可以手动禁止 hyperfine 使用 shell 来执行程序的行为。<br>hyperfine 本身也会检测 shell 对测量结果的影响，并且在她觉得 shell 对测量结果的<br>影响已经大到不可忽略时提出警告。判定规则与细节将在之后描述。</p><h2 id="使用进阶"><a href="#使用进阶" class="headerlink" title="使用进阶"></a>使用进阶</h2><p>现在，你已经基本学会用 hyperfine 了！让我们来看看一些更好玩的东西吧。</p><h3 id="测试-IO-密集型程序"><a href="#测试-IO-密集型程序" class="headerlink" title="测试 IO 密集型程序"></a>测试 IO 密集型程序</h3><p>假设我们要运行一个大量读写磁盘文件的程序 10 次，我们会发现什么怪现象呢？我们<br>会发现，第一次或前几次运行所花费的时间会显著大于后面几次。这是由于 Linux 系统<br>有 Page Cache 的机制，它会尽可能努力地把最近使用过的文件缓存在内存里。</p><p>在第一次运行的时候，程序试图读文件。操作系统发现内存里没有相关文件，只好老老实<br>实地从磁盘上把文件读出来再交给程序。但是紧接着程序运行第二三四次，程序试图读文<br>件时，操作系统发现文件刚刚才被读过，还被缓存在内存里，于是直接把内存中的内容交<br>给程序，直接省略掉了读盘的过程。众所周知，内存的读写速度一般远大于硬盘。这导致<br>了第二三四次运行程序时，程序用时会显著少于第一次。</p><p>类似的情况还会出现在很多具有缓存机制的系统（没有特指操作系统！）里。在对于这些<br>系统打交道的程序计时时，我们需要给 hyperfine 加一些参数。</p><h4 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h4><p>我们可以使用 <code>--warmup N</code> 的参数让程序被真正计时之前，先运行 N 次，其中 N 是一<br>个整数。比如，<code>hyperfine --warmup 2 sleep 3</code> 这个命令实际上会运行 <code>sleep 3</code> 这<br>个命令 12 次，其中最后 10 次会被计时。</p><p>这种方式有利于将程序需要用到的东西提前装到缓存里。可以测量程序在缓存工作良好时<br>的运行效率。</p><h4 id="提前执行指令"><a href="#提前执行指令" class="headerlink" title="提前执行指令"></a>提前执行指令</h4><p>我们可以使用 <code>--prepare X</code> 的参数让 hyperfine 每次运行程序之前，先运行一下 X，<br>其中 X 是一条 shell 命令。比如，<br><code>hyperfine --prepare &#39;echo 3 | sudo tee /proc/sys/vm/drop_caches&#39; sleep 3</code><br>这个命令，会运行 <code>sleep 3</code> 10 次，但是每次运行前，会运行<br><code>echo 3 | sudo tee /proc/sys/vm/drop_caches</code> 一次，来清除 Linux 的 Page Cache。</p><p>这种方式直接让缓存没用了。可以测量程序冷启动的速度。</p><h3 id="测试运行时间过短的程序"><a href="#测试运行时间过短的程序" class="headerlink" title="测试运行时间过短的程序"></a>测试运行时间过短的程序</h3><p>之前说到，hyperfine 会用一个 shell 来执行待计时的程序。但是如果程序跑得很快，<br>导致 shell 启动、解析、执行的时间已经占总用时不小的一部分了，那么测量误差就会<br>变得不可接受。</p><p>这个时候我们就可以使用 <code>-N</code> 参数来制止 hyperfine 使用 shell。此时，她会用一个<br>内置的简陋的解析器来把命令的可执行文件和参数给分开。这个简陋的解析器主要使用<br>空白字符来分割参数，但是也支持基础的转义字符和引号。</p><p>比如：</p><pre><code>hyperfine -N &#39;touch x&#39;</code></pre><h3 id="不知道自己的程序属于哪种类型？"><a href="#不知道自己的程序属于哪种类型？" class="headerlink" title="不知道自己的程序属于哪种类型？"></a>不知道自己的程序属于哪种类型？</h3><p>有笨比……</p><p>如果你不知道你的程序要跑多久，也不知道它是不是要用到某种缓存系统，直接把它当成<br>纯计算的程序来测就行了。hyperfine 会在发现不对劲时来提醒你。</p><p>下面是几个例子：</p><h4 id="奇怪的测量结果"><a href="#奇怪的测量结果" class="headerlink" title="奇怪的测量结果"></a>奇怪的测量结果</h4><pre><code>20:21 jyi-station ~/tmp/bgifile0 hyperfine &#39;cat test18.c&#39;Benchmark 1: cat test18.c  Time (mean ± σ):      16.9 ms ±   1.0 ms    [User: 1.1 ms, System: 15.9 ms]  Range (min … max):    15.7 ms …  22.1 ms    154 runs  Warning: Statistical outliers were detected. Consider re-running this  benchmark on a quiet system without any interferences from other programs.  It might help to use the &#39;--warmup&#39; or &#39;--prepare&#39; options.</code></pre><p>hyperfine 发现测试的时候，有些数据与别的明显不在一个等级。所以她警告你并且建议<br>你在系统闲的时候重跑。</p><h4 id="初次测量很慢"><a href="#初次测量很慢" class="headerlink" title="初次测量很慢"></a>初次测量很慢</h4><pre><code>20:21 jyi-station ~/tmp/bgifile0 hyperfine &#39;cat test19.c&#39;Benchmark 1: cat test19.c  Time (mean ± σ):      34.3 ms ±  14.1 ms    [User: 2.2 ms, System: 31.8 ms]  Range (min … max):    30.4 ms … 105.4 ms    28 runs  Warning: The first benchmarking run for this command was significantly slower  than the rest (105.4 ms). This could be caused by (filesystem) caches that  were not filled until after the first run. You should consider using the  &#39;--warmup&#39; option to fill those caches before the actual benchmark.  Alternatively, use the &#39;--prepare&#39; option to clear the caches before each  timing run.</code></pre><p>这次 hyperfine 不仅发现数据异常，还发现是第一次跑的时候数据异常。于是她猜测是<br>某种神秘的缓存系统起了作用，并且建议你用 <code>--warmup</code> 参数或 <code>--prepare</code> 参数来<br>消除缓存的影响。</p><h4 id="程序跑得很快"><a href="#程序跑得很快" class="headerlink" title="程序跑得很快"></a>程序跑得很快</h4><pre><code>20:21 jyi-station ~/tmp/bgifile0 hyperfine &#39;cat test1.c&#39;Benchmark 1: cat test1.c  Time (mean ± σ):       0.9 ms ±   0.1 ms    [User: 0.7 ms, System: 0.4 ms]  Range (min … max):     0.7 ms …   1.3 ms    1340 runs  Warning: Command took less than 5 ms to complete. Note that the results  might be inaccurate because hyperfine can not calibrate the shell startup  time much more precise than this limit. You can try to use the  `-N`/`--shell=none` option to disable the shell completely.</code></pre><p>这次，hyperfine 发现程序跑得很快，误差会比较大，并且建议你用 <code>-N</code> 参数来直接运行程序，<br>绕过启动 shell 的步骤。</p><h3 id="额外的功能"><a href="#额外的功能" class="headerlink" title="额外的功能"></a>额外的功能</h3><p>除此之外，hyperfine 还有一些别的功能，比如参数化测试之类的东西。不过我感觉要参<br>数化的话与其用这一坨命令行参数，不如去写一个小小脚本……所以我没用过。如果有人感<br>兴趣的话可以试试。</p><h2 id="改变输出格式以便与其他软件协作"><a href="#改变输出格式以便与其他软件协作" class="headerlink" title="改变输出格式以便与其他软件协作"></a>改变输出格式以便与其他软件协作</h2><p>hyperfine 的命令行界面很好看，有进度条还有颜色。在除命令行之外的地方，她也做得<br>很好。比如，hyperfine 可以直接用 <code>--export-markdown</code> 参数生成 markdown 表格，<br>接着你就可以直接把结果插进 README 里面。她还可以导出 json 格式的测试结果，方便<br>之后再用脚本处理，做些可视化什么的（hyperfine 的仓库就附带了许多可视化脚本，很<br>好玩）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测量程序性能的方式有很多。相比那些在函数调用上插桩（gprof）或读 PMC 寄存器<br>（perf）的东西来说，单纯的计时也许太简陋了一些。但是第一次参观 profiler，却并<br>不觉得震撼。因为我早已遇见，独属于我的 benchmarking tool。初遇你的那天起，齿轮<br>便开始转动，却无法阻止丧失的预感。尽管已经拥有了很多，但让我们再多加一个吧。<br>可以给我最后一个加速比吗？我不愿遗忘</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hyperfine-使用指南&quot;&gt;&lt;a href=&quot;#hyperfine-使用指南&quot; class=&quot;headerlink&quot; title=&quot;hyperfine 使用指南&quot;&gt;&lt;/a&gt;hyperfine 使用指南&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些能够节省按键次数的 bash 配置</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/shell-abbr/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/shell-abbr/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些能够节省按键次数的-bash-配置"><a href="#一些能够节省按键次数的-bash-配置" class="headerlink" title="一些能够节省按键次数的 bash 配置"></a>一些能够节省按键次数的 bash 配置</h1><p>众所周知，敲击键盘的同时，人的手指会经历一系列的磨损。长此以往，手指就会变短。为了保护手指，使用下面的 bash 配置，成为和我一样能少按键盘就少按键盘的人吧！</p><h2 id="给命令起单个字符的别名"><a href="#给命令起单个字符的别名" class="headerlink" title="给命令起单个字符的别名"></a>给命令起单个字符的别名</h2><p>对于一些常用的命令，如果没有重复命令，可以给他们起单个字符的别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> a=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> g=<span class="string">&#x27;grep&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> j=<span class="string">&#x27;jobs -l&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> o=<span class="string">&#x27;xdg-open&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> r=<span class="string">&#x27;rm&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> t=<span class="string">&#x27;task&#x27;</span> <span class="comment"># taskwarrior: 一个 todo-list 小软件</span></span><br><span class="line"><span class="built_in">alias</span> v=<span class="string">&#x27;vi&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -- -=<span class="string">&#x27;cd -&#x27;</span> <span class="comment"># 这里的意思是将 - 作为 cd - 的别名</span></span><br></pre></td></tr></table></figure><p>但是这些写法在 xargs 这里出了点小问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% 17:51:28 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 alias x=&#x27;xargs&#x27;</span><br><span class="line">% 17:51:32 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 l|x g hello</span><br><span class="line">xargs: g: No such file or directory</span><br></pre></td></tr></table></figure><p>我们的本意是想让它运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | xargs grep hello</span><br></pre></td></tr></table></figure><p>但由于 <code>g</code> 并不是命令，xargs 报了错。要是我们想让 <code>x</code> 被展开为 <code>xargs</code> 后，其后的 <code>g</code> 继续被展开，我们可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> x=<span class="string">&#x27;xargs &#x27;</span> <span class="comment"># 注意，xargs 与第二个单引号之间有一个空格</span></span><br></pre></td></tr></table></figure><p>之后再运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 17:58:29 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">1 l</span><br><span class="line">a.md</span><br><span class="line">% 17:58:30 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">1 l|x g &#x27;`xargs`&#x27;</span><br><span class="line">由于 `g` 并不是命令，xargs 报了错。要是我们想让 `x` 被展开为 `xargs` 后，其后的 `g` 继续被展开，我们可以这样写：</span><br></pre></td></tr></table></figure><p>就好了。这是 bash 的小特性，结尾的空格可以让下一个标识符展开（如果是别名的话）。同理，我们对 <code>sudo</code> 也做类似的事情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> s=<span class="string">&#x27;sudo &#x27;</span></span><br></pre></td></tr></table></figure><p>太方便辣！</p><p>此外，单个 <code>%</code> 的作用和 <code>fg</code> 相同，都是让后台进程回到前台。</p><h2 id="给有歧义的命令们起一样的名字"><a href="#给有歧义的命令们起一样的名字" class="headerlink" title="给有歧义的命令们起一样的名字"></a>给有歧义的命令们起一样的名字</h2><p>我日常使用 <code>find</code> 和 <code>file</code> 比较频繁，正常人在缩写他们时，都会想到用 <code>f</code> 来作为它们的别名。而如果一个用 <code>f</code> 作了别名，另一个就只能用其他奇奇怪怪的缩写。有没有办法让它们共用一个名字呢？</p><p>由于脑机接口尚未开发完成，shell 无法通过魔法装置读取我们的思想，知道我们在运行 <code>f</code> 时究竟是想运行 <code>find</code>，还是 <code>file</code>，我们只能手动实现一个 shell 函数，根据上下文猜测输入时究竟想要什么。</p><p>（怎么有种 Perl 猜代码块和匿名哈希的感觉）</p><p>这是一个简单的示例，可以根据实际使用情况另作调整。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find, file</span></span><br><span class="line"><span class="function"><span class="title">f</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">local</span> i</span><br><span class="line"><span class="built_in">local</span> expect_find=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发现身处管道之中，stdin 里不是终端，有输入，则猜测想要</span></span><br><span class="line"><span class="comment"># 确定 stdin 中文件的类型</span></span><br><span class="line"><span class="keyword">if</span> ! [ -t 0 ]; <span class="keyword">then</span></span><br><span class="line">file -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 stdin 是终端，但是没有参数，猜测是想要递归列出当前目录</span></span><br><span class="line"><span class="comment"># 下的文件，调用 find</span></span><br><span class="line"><span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">find</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有参数以连字符（-）打头，则猜测是 find 的参数，</span></span><br><span class="line"><span class="comment"># 比如 -name -type 之类的。</span></span><br><span class="line"><span class="comment"># 如果参数没有以连字符打头的，则猜测是 file 的参数，参数</span></span><br><span class="line"><span class="comment"># 都是文件名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;i:0:1&#125;</span>&quot;</span> = <span class="string">&#x27;-&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">expect_find=y</span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$expect_find</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">find <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">file <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用看起来还不错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% 18:56:38 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f</span><br><span class="line">.</span><br><span class="line">./a.md</span><br><span class="line">% 18:56:40 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f &lt; a.md</span><br><span class="line">/dev/stdin: UTF-8 Unicode text</span><br><span class="line">% 18:56:42 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f -type f</span><br><span class="line">./a.md</span><br><span class="line">% 18:56:45 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f a.md</span><br><span class="line">a.md: UTF-8 Unicode text</span><br></pre></td></tr></table></figure><p>这样基本符合日常使用，无法处理的边边角角的情况打全名也不是不能接受啦。</p><p>还有一些类似的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c()</span><br><span class="line">&#123;</span><br><span class="line"># 复制？还是复制到剪贴板？</span><br><span class="line">if [ -t 0 ] &amp;&amp; [ &quot;$#&quot; -ge 2 ]; then</span><br><span class="line">cp &quot;$@&quot;</span><br><span class="line">else</span><br><span class="line">clip &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line">&#123;</span><br><span class="line"># 调用分页器（pager）？还是打印当前目录？</span><br><span class="line">if [ -z &quot;$1&quot; ] &amp;&amp; [ -t 0 ]; then</span><br><span class="line">pwd</span><br><span class="line">else</span><br><span class="line">less -F &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给小工具更多的默认行为"><a href="#给小工具更多的默认行为" class="headerlink" title="给小工具更多的默认行为"></a>给小工具更多的默认行为</h2><p>有时一些操作总是连在一起的，比如新建文件夹然后切换进去，我们可以用这样的神奇函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">md</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> || <span class="built_in">return</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们经常将别处的文件移到当前文件夹，使用这个函数，这样我们可以省略最后那个 <code>.</code> 参数。因为奇怪的原因，只有在有且仅有一个参数时才会有这个功能。有多个参数时总会有无法解决的歧义问题。（不过这样已经足够好了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">m</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> too few arguments</span><br><span class="line"><span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> .</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，执行 <code>cd</code> 再执行 <code>ls</code> 应该是某种常规的操作，每年因为这项操作没有优化，无数根手指被磨短。当然可以把 <code>cd</code> 变成 <code>cd &amp;&amp; ls</code>，但是我们想到了一种更加酷炫的方法来解决这个问题，放在另一个部分说。</p><h2 id="开启大量-shell-内置特性"><a href="#开启大量-shell-内置特性" class="headerlink" title="开启大量 shell 内置特性"></a>开启大量 shell 内置特性</h2><p>bash 内置了大量方便的扩展特性，这些特性可以使用 <code>shopt -s &lt;特性名称&gt;</code> 打开。比如：<code>shopt -s autocd</code>。</p><h3 id="autocd"><a href="#autocd" class="headerlink" title="autocd"></a>autocd</h3><p>自动切换目录……意思是假设当前目录下有一个名为 <code>my-doc</code> 的子目录，可以用 <code>my-doc</code> 取代 <code>cd my-doc</code>。这有一个小问题，由于补全时 bash 并不知道想输入的是目录还是指令，指令会和目录一起进入补全列表，又慢又难选。使用 <code>./my-doc</code> 会好很多。</p><h3 id="checkwinsize"><a href="#checkwinsize" class="headerlink" title="checkwinsize"></a>checkwinsize</h3><p>在终端窗口变化时重新设置 <code>$LINES</code> 和 <code>$COLUMNS</code></p><h3 id="dotglob"><a href="#dotglob" class="headerlink" title="dotglob"></a>dotglob</h3><p>匹配隐藏文件，这个按个人需求而定？我是觉得这个选项很酷所以打开了。</p><h3 id="extglob"><a href="#extglob" class="headerlink" title="extglob"></a>extglob</h3><p>扩展的匹配，完全没用！真的好难用，试图给通配符加上一些正则表达式的扩展，还没有 <code>find</code> <code>sed</code> <code>grep</code> <code>xargs</code> 香。</p><h3 id="failglob"><a href="#failglob" class="headerlink" title="failglob"></a>failglob</h3><p>没有匹配时报错而不是将模式作为参数传递给程序。非常有用，能避免一堆奇奇怪怪问题。比如：</p><p>开启前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% 19:21:49 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 touch *.c # 我要摸摸所有 c 文件</span><br><span class="line">% 19:21:49 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 ls</span><br><span class="line"> a.md  &#x27;*.c&#x27; # 啊不好了，他给我新建了一个 ./*.c</span><br></pre></td></tr></table></figure><p>开启后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 19:23:23 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 touch *.c</span><br><span class="line">-bash: no match: *.c # 没有找到！</span><br><span class="line">% [1] 19:23:28 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 ls</span><br><span class="line">a.md</span><br></pre></td></tr></table></figure><h3 id="globstar"><a href="#globstar" class="headerlink" title="globstar"></a>globstar</h3><p>让 <code>**</code> 通配符支持递归进子文件夹的匹配，比如 my&#x2F;**&#x2F;file 可以匹配 my&#x2F;magic&#x2F;powerful&#x2F;fancy&#x2F;file ，可以用来部分代替 <code>find</code>。</p><h2 id="全自动的-ls"><a href="#全自动的-ls" class="headerlink" title="全自动的 ls"></a>全自动的 ls</h2><p>有时我们希望当前目录下文件发生改变，或工作目录发生改变时，自动 <code>ls</code> 一下展示目录现状。</p><p>我们很容易写出这样的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次运行，保存工作目录和当前目录内容（的哈希值）</span></span><br><span class="line">LAST_LS=$(<span class="built_in">command</span> <span class="built_in">ls</span> | <span class="built_in">sum</span>)</span><br><span class="line">LAST_PWD=<span class="string">&quot;<span class="variable">$PWD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_prompt_smart_ls</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">local</span> this_ls</span><br><span class="line">this_ls=$(<span class="built_in">command</span> <span class="built_in">ls</span> | <span class="built_in">sum</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$LAST_LS</span>&quot;</span> != <span class="string">&quot;<span class="variable">$this_ls</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$LAST_PWD</span>&quot;</span> != <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">LAST_LS=<span class="string">&quot;<span class="variable">$this_ls</span>&quot;</span></span><br><span class="line">LAST_PWD=<span class="string">&quot;<span class="variable">$PWD</span>&quot;</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，每调用一次 <code>_prompt_smart_ls</code>，它都会检查工作目录和当前目录内容，如果发现有不一样的地方，就 <code>ls</code> 一次。我们只要想办法每执行一次指令，就调用一次这个函数就行了。</p><p>（当然也可以用其他的检查方式，比如使用神奇的守护进程监视文件系统变化，再和 shell 通信，但是其他方法好像都没有每执行完一次指令就检查一次简单有效）</p><p>怎么做到每执行一次命令，就调用一次函数呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROMPT_COMMAND=<span class="string">&#x27;_prompt_smart_ls&#x27;</span></span><br></pre></td></tr></table></figure><p>使用 bash 魔法变量，bash 会在执行每条命令后自动执行 <code>PROMPT_COMMAND</code> 这个变量里所存的命令。</p><p>最后效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% 20:17:09 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 touch test</span><br><span class="line">a.md  test</span><br><span class="line">% 20:17:12 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 rm test</span><br><span class="line">a.md</span><br><span class="line">% 20:17:13 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 cd /</span><br><span class="line">bin/   dev/  home/  lib/    lost+found/  mnt/  proc/  run/   srv/  tmp/  var/</span><br><span class="line">boot/  etc/  init*  lib64/  media/       opt/  root/  sbin/  sys/  usr/</span><br></pre></td></tr></table></figure><p>太炫酷了！</p><h2 id="更多的-cd"><a href="#更多的-cd" class="headerlink" title="更多的 cd"></a>更多的 cd</h2><p>我们知道设置了 <code>autocd</code> 之后，输入 <code>..</code> 会自动切换到上级目录……我们可以做得更多！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ...=<span class="string">&#x27;cd ../..&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ....=<span class="string">&#x27;cd ../../../&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="使用外部工具！"><a href="#使用外部工具！" class="headerlink" title="使用外部工具！"></a>使用外部工具！</h2><p>仔细想了想，发现平时使用 <code>z.sh</code> 按访问频率自动跳转时，有时会跳转到自己不希望的位置，如果能够选择跳转到哪里就好了。</p><p>我们还需要可见的界面！这个想法是从 zsh 的补全里偷来的，感觉可以上下左右选择非常厉害。</p><p>所以使用 <code>fzf</code> 配合 <code>z.sh</code>，做出非常友好的跳转方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fz</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">local</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">dir</span>=<span class="string">&quot;<span class="subst">$(z | sed &#x27;s/^[0-9. \t]*//&#x27; |fzf -1 -0 --no-sort --tac +m)</span>&quot;</span> &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> || <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的重新加载配置的方法"><a href="#正确的重新加载配置的方法" class="headerlink" title="正确的重新加载配置的方法"></a>正确的重新加载配置的方法</h2><p>修改了 <code>.bashrc</code> 文件，想要试用一番！怎么加载配置文件呢？</p><p><code>source ~/.bashrc</code>：不好，前任配置文件中残留的 alias 尸体、环境变量可能会影响使用，尤其是写错了的情况下……</p><p><code>bash</code>：不好，退出的时候也要连按许多 exit 或者 Ctrl-D</p><p><code>bash; exit</code>：比上一个好，但是会影响 <code>$SHLVL</code> 变量，可能会对一些奇特脚本（比如 debian 11 下的 <code>~/.bash_logout</code>）造成影响。</p><p><code>exec bash</code>：非常好！用了 <code>exec bash</code>，亩产一千八！</p><p>所以这是重新加载配置文件的缩写（reload）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> rl=<span class="string">&#x27;exec bash&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>打键盘是不错，但是也别敲过了头。打键盘打得太多，手指可就被磨短了。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些能够节省按键次数的-bash-配置&quot;&gt;&lt;a href=&quot;#一些能够节省按键次数的-bash-配置&quot; class=&quot;headerlink&quot; title=&quot;一些能够节省按键次数的 bash 配置&quot;&gt;&lt;/a&gt;一些能够节省按键次数的 bash 配置&lt;/h1&gt;&lt;p&gt;众所</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客园上可用的 markdown 目录生成器</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/toc-for-cnblogs/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/toc-for-cnblogs/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.356Z</updated>
    
    <content type="html"><![CDATA[<p>为 markdown 写的文章生成目录，使其在博客园上可用。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> v5.<span class="number">12</span>;</span><br><span class="line"><span class="keyword">use</span> utf8;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:utf8&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:std&#x27;</span>, <span class="string">&#x27;:utf8&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> @subtitle_number;</span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;# 目录&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (&lt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> /^<span class="string">``</span><span class="string">`/ ... /^`</span><span class="string">``</span>/;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^(#+)\s*(.*?)\s*$/</span>) &#123;</span><br><span class="line">        <span class="keyword">my</span> ($level, $title) = (<span class="keyword">length</span>($1), $2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">my</span> $indent = <span class="string">&quot;  &quot;</span> <span class="keyword">x</span> $level;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">my</span> $id = $title;</span><br><span class="line">        $id =~ <span class="regexp">s/[^_[:^punct:]]//g</span>;</span><br><span class="line">        $id =~ <span class="regexp">s/[[:space:]]/-/g</span>;</span><br><span class="line">        $id = <span class="keyword">lc</span> $id;</span><br><span class="line"></span><br><span class="line">        @subtitle_number = <span class="keyword">splice</span> @subtitle_number, <span class="number">0</span>, $level;</span><br><span class="line">        $subtitle_number[$level - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">my</span> $subtitle_number = <span class="keyword">join</span> <span class="string">&quot;.&quot;</span>, @subtitle_number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">say</span> <span class="string">&quot;$indent+ $subtitle_number [$title](#$id)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>这是一个 Perl 脚本，从 stdin 或者参数中读取文章，输出一份 markdown 代码，是文章的目录。可以直接复制粘贴使用，也可以和其他工具集成使用。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>使用这样的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl toc.pl main.md</span><br></pre></td></tr></table></figure><p>可以得到这样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 目录</span><br><span class="line">  + 1 [完整代码](#完整代码)</span><br><span class="line">  + 2 [使用示例](#使用示例)</span><br><span class="line">  + 3 [原理](#原理)</span><br><span class="line">    + 3.1 [HTML 的链接语法](#html-的链接语法)</span><br><span class="line">    + 3.2 [markdown 列表缩进](#markdown-列表缩进)</span><br><span class="line">  + 4 [代码详解](#代码详解)</span><br><span class="line">    + 4.1 [使用「现代」Perl](#使用现代perl)</span><br><span class="line">    + 4.2 [支持 utf8 编码](#支持-utf8-编码)</span><br><span class="line">    + 4.3 [主循环](#主循环)</span><br><span class="line">      + 4.3.1 [跳过 markdown 的代码片段](#跳过-markdown-的代码片段)</span><br><span class="line">      + 4.3.2 [匹配标题](#匹配标题)</span><br><span class="line">      + 4.3.3 [设置缩进](#设置缩进)</span><br><span class="line">      + 4.3.4 [从标题名字中获得其 id](#从标题名字中获得其-id)</span><br><span class="line">      + 4.3.5 [获取标题的编号](#获取标题的编号)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="HTML-的链接语法"><a href="#HTML-的链接语法" class="headerlink" title="HTML 的链接语法"></a>HTML 的链接语法</h2><p>在大多数网页上，markdown 的链接语法会被编译成 HTML 的 <code>&lt;a&gt;</code> 标签。通常 <code>&lt;a&gt;</code> 标签会有 <code>href</code> 属性，内容是点击标签时跳转的目的地址。</p><p>有些页内元素带有 <code>id</code> 属性，比如这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;interactive-shell&quot;</span>&gt;</span>interactive shell<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子里 <code>&lt;h3&gt;</code> 标签有 <code>id</code> 属性，值是 <code>interactive-shell</code>。这个值同样可以用作 <code>&lt;a&gt;</code> 标签的目的地址。</p><p>当目的地址是页内元素的 <code>id</code> 时，点击 <code>&lt;a&gt;</code> 标签时便会跳转到该元素的位置。博客园给每个标题都自动分配了一个 <code>id</code>，利用这几点，就可以实现「点击目录项目跳转到对应章节」的功能。</p><h2 id="markdown-列表缩进"><a href="#markdown-列表缩进" class="headerlink" title="markdown 列表缩进"></a>markdown 列表缩进</h2><p>在 markdown 中，列表以 <code>+</code> <code>-</code> 和 <code>*</code> 开头。如果这些符号前面有空白字符，那么这些空白字符会被当成缩进，最终会体现在列表展示结果上，缩进越多的列表项目展示时会越靠右，缩进相同的列表项目会左对齐。利用这一点，可以实现目录的层次结构。</p><h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><h2 id="使用「现代」Perl"><a href="#使用「现代」Perl" class="headerlink" title="使用「现代」Perl"></a>使用「现代」Perl</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> v5.<span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>Perl 是个老古董语言，为了保持兼容性，有许多好玩&#x2F;有用的特性默认没有打开。不过我们可以使用 <code>use vX.YY</code> 的 pragma 来指定自己想使用的 Perl 的版本号，从而开启这些好玩的特性。</p><h2 id="支持-utf8-编码"><a href="#支持-utf8-编码" class="headerlink" title="支持 utf8 编码"></a>支持 utf8 编码</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> utf8;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:utf8&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:std&#x27;</span>, <span class="string">&#x27;:utf8&#x27;</span>;</span><br></pre></td></tr></table></figure><p>同上，因为 Perl 是个老古董语言，所以默认全世界都用 ASCII 编码。我们要开启它对 utf8 的支持。</p><p>这里第一行是让 Perl 用 utf8 的方式来解释这份源代码（有点像 python2 里面的 <code># -*- coding: utf-8 -*-</code> 的 pragma）。</p><p>第二行是让 Perl 读所有文件时，读后解码 utf8；写所有文件时，写前编码 utf8。Perl 中为了方便数据处理，存在 IO Layer 的概念。layer 可以看做数据的转换器，数据在进行输入&#x2F;输出时，会经过这些 layer 逐层处理。常用的 layer 有 <code>:crlf</code>（读时将 <code>CR-LF</code> 序列转换成 <code>CR</code>，写时反过来，用来对付 Windows 系统）和 <code>:encoding</code>（用来编解码文件）。还有些邪恶的 layer 可以实现自动压缩解压、base16 编码等功能。所以有时遇到输出到 stdout 和输出到文件中，内容不一致的情况，可以检查一下是不是用的 layer 不同造成的。</p><p>第三行是在设置 stdio 的 layer。因为 stdio 在 Perl 程序运行前就已经打开了，所以需要单独设置一下。</p><h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><p>就是那个巨大的 <code>while</code> 循环。它每次会从输入中读取一行数据并放到 <code>$_</code> 里面，直到读到文件结束。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (&lt;&gt;) &#123;</span><br></pre></td></tr></table></figure><p>可以发现我们并没有处理命令行参数，这是因为 <code>&lt;&gt;</code> 这个操作符会替我们完成这项工作。<code>&lt;&gt;</code> 操作符的意思是，如果有命令行参数，那么就把命令行参数当做文件名打开文件，并且将文件内容作为输入；否则就把 stdin 作为输入。每调用一次 <code>&lt;&gt;</code> 操作符会读取一行，返回这一行的内容。如果没有变量来接收 <code>&lt;&gt;</code> 操作符的返回值，那么 <code>&lt;&gt;</code> 操作符会把返回值存在特殊变量 <code>$_</code> 中。</p><h3 id="跳过-markdown-的代码片段"><a href="#跳过-markdown-的代码片段" class="headerlink" title="跳过 markdown 的代码片段"></a>跳过 markdown 的代码片段</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">next</span> <span class="keyword">if</span> /^<span class="string">``</span><span class="string">`/ ... /^`</span><span class="string">``</span>/;</span><br></pre></td></tr></table></figure><p>这一行用来跳过 markdown 的代码片断。是一种被称为 flip-flop 的语法。上面代码的意思是，「如果在两个代码标记之间，那么执行 <code>next</code> 语句」。大概和下面的东西等价：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这句在循环外头</span></span><br><span class="line"><span class="keyword">my</span> $in_codeblock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这下面的在循环里头</span></span><br><span class="line"><span class="keyword">if</span> ($in_codeblock) &#123;</span><br><span class="line">    <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/^```/</span> &amp;&amp; $in_codeblock == <span class="number">0</span>) &#123;</span><br><span class="line">    $in_codeblock = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/^```/</span> &amp;&amp; $in_codeblock == <span class="number">1</span>) &#123;</span><br><span class="line">    $in_codeblock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flip-flop 是一种很方便的语法，可以让人少写很多代码。最重要的是不需要对那一堆烦人的标志变量命名了。</p><h3 id="匹配标题"><a href="#匹配标题" class="headerlink" title="匹配标题"></a>匹配标题</h3><p>用一个正则表达式来匹配标题并且获得需要的信息：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^(#+)\s*(.*?)\s*$/</span>) &#123;</span><br><span class="line">    <span class="keyword">my</span> ($level, $title) = (<span class="keyword">length</span>($1), $2);</span><br></pre></td></tr></table></figure><p>这个意思是，如果遇到「开头是若干个 <code>#</code>，中间有一堆字符」这种模式，就认为匹配到标题了。<code>$level</code> 和 <code>$title</code> 分别是标题的层级和名称。因为正则表达式在 Perl 中用的特别多，所以直接做进语言里面去了，可以随手写，不需要另外调库。</p><h3 id="设置缩进"><a href="#设置缩进" class="headerlink" title="设置缩进"></a>设置缩进</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $indent = <span class="string">&quot;  &quot;</span> <span class="keyword">x</span> $level;</span><br></pre></td></tr></table></figure><p><code>$level</code> 总是个整数。这里用字符串重复操作符 <code>x</code>，来获得与 <code>$level</code> 成正比的缩进长度。</p><h3 id="从标题名字中获得其-id"><a href="#从标题名字中获得其-id" class="headerlink" title="从标题名字中获得其 id"></a>从标题名字中获得其 id</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $id = $title;</span><br><span class="line">$id =~ <span class="regexp">s/[^_[:^punct:]]//g</span>;</span><br><span class="line">$id =~ <span class="regexp">s/[[:space:]]/-/g</span>;</span><br><span class="line">$id = <span class="keyword">lc</span> $id;</span><br></pre></td></tr></table></figure><p>博客园会根据标题名称来设置其 HTML 标签的 id。有人托梦告诉我说，id 就是标题去掉所有标点符号但是保留下划线 <code>_</code>，把空白字符换成连字符 <code>-</code>，并且把所有字母变为小写之后的结果。所以用正则表达式写了一个。</p><h3 id="获取标题的编号"><a href="#获取标题的编号" class="headerlink" title="获取标题的编号"></a>获取标题的编号</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@subtitle_number = <span class="keyword">splice</span> @subtitle_number, <span class="number">0</span>, $level;</span><br><span class="line">$subtitle_number[$level - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">my</span> $subtitle_number = <span class="keyword">join</span> <span class="string">&quot;.&quot;</span>, @subtitle_number;</span><br></pre></td></tr></table></figure><p>生成的目录里面会有类似 <code>X.Y.Z.W</code> 这样的标题编号。这一部分代码就用来处理标题编号的生成问题。懒得写了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为 markdown 写的文章生成目录，使其在博客园上可用。&lt;/p&gt;
&lt;h1 id=&quot;完整代码&quot;&gt;&lt;a href=&quot;#完整代码&quot; class=&quot;headerlink&quot; title=&quot;完整代码&quot;&gt;&lt;/a&gt;完整代码&lt;/h1&gt;&lt;figure class=&quot;highlight pe</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bottles 安装</title>
    <link href="https://jyi2ya.github.io/2023/10/01/tutorial/wine-bottles/main/"/>
    <id>https://jyi2ya.github.io/2023/10/01/tutorial/wine-bottles/main/</id>
    <published>2023-10-01T17:48:39.000Z</published>
    <updated>2024-01-13T13:43:01.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bottles-安装"><a href="#Bottles-安装" class="headerlink" title="Bottles 安装"></a>Bottles 安装</h1><h2 id="好名字！"><a href="#好名字！" class="headerlink" title="好名字！"></a>好名字！</h2><p><a href="https://docs.usebottles.com/">Bottles</a> 是类似 winetricks 的小软件，用于自动配置 wine、自动安装并配置软件。至于为什么有了 winetricks 还需要新的小软件，bottles 在他们官网上给出了<a href="https://docs.usebottles.com/faq/where-is-winetricks">解释</a>：bottles 希望提供中心化的依赖处理系统，并且希望拥有比 winetricks 更强的扩展性。总之不是重复造轮子就对了。</p><p>之前试着用 winetricks 一键安装 qq，结果有一个托管在 ftp.hp.org 上的文件一直下载不下来。接着我就把 winetricks 扬了。</p><p>Wine bottles，酒瓶子。:D</p><h2 id="安装和安装过程的问题修复"><a href="#安装和安装过程的问题修复" class="headerlink" title="安装和安装过程的问题修复"></a>安装和安装过程的问题修复</h2><p>参考<a href="https://docs.usebottles.com/getting-started/installation">官方的安装指南</a></p><h3 id="直接使用包管理器安装"><a href="#直接使用包管理器安装" class="headerlink" title="直接使用包管理器安装"></a>直接使用包管理器安装</h3><p><a href="https://docs.usebottles.com/getting-started/installation">官方的安装指南</a>里面说，bottles 在多个发行版的源里有包。比如 fedora，就可以使用 <code>sudo dnf install bottles</code> 来安装。其他支持的发行版可以去安装指南里头看看。</p><p>但是 debian 源竟然没有包，神奇……明明代码目录里有个 <code>debian/</code>，这不指明了是要人打包吗？</p><h3 id="编译-deb-包，再使用包管理器安装"><a href="#编译-deb-包，再使用包管理器安装" class="headerlink" title="编译 deb 包，再使用包管理器安装"></a>编译 deb 包，再使用包管理器安装</h3><h4 id="编译-deb-包"><a href="#编译-deb-包" class="headerlink" title="编译 deb 包"></a>编译 deb 包</h4><p>因为 debian 源里面没有 bottles 的包，所以我们需要编译代码。同时为了维护依赖，便于删除，我们利用代码目录里面 <code>debian/</code> 下的东西把它打成 deb 包，再使用 <code>apt</code> 命令安装。</p><p>bottles 使用 meson 和 ninja 作为构建系统。听说这两个东西很先进，打算改天去学一下。从 <a href="https://blog.devgenius.io/how-to-build-debian-packages-from-meson-ninja-d1c28b60e709">devgenius.io</a> 上现学了怎么使用 meson&#x2F;ninja 打 deb 包：</p><ol><li>首先安装 <code>debhelper</code> <code>build-essentials</code> 和 <code>dh-make</code>。其中 <code>debhelper</code> 和 <code>dh-make</code> 是 debian 的软件包构建相关工具。<code>build-essentials</code> 则是软件开发的基础工具，包含 <code>make</code> 等小工具。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install debhelper build-essentials dh-make</span><br></pre></td></tr></table></figure><ol start="2"><li>接着下载代码并且进入环境：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bottlesdevs/Bottles</span><br><span class="line"><span class="built_in">cd</span> Bottles</span><br></pre></td></tr></table></figure><ol start="3"><li>然后运行 debian 包的自动配置脚本，指定构建系统为 meson：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dh_auto_configure --buildsystem=meson</span><br></pre></td></tr></table></figure><ol start="4"><li>最后运行构建软件包的命令。参数的 <code>-b</code> 是指仅构建二进制的 deb 包。因为是命令是偷来的所以也不是很清楚参数有什么用……</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-buildpackage -rfakeroot -us -uc -b</span><br></pre></td></tr></table></figure><ol start="5"><li>回到上级目录，发现 deb 包出现了！</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../ &amp;&amp; <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total 284</span><br><span class="line">drwxrwxr-x 1 root root    672 Mar  5 20:02 Bottles-2022.2.28-trento-2/</span><br><span class="line">-rw-r--r-- 1 root root   6872 Mar  5 20:02 com.usebottles.bottles_2022.2.28-trento-2_amd64.buildinfo</span><br><span class="line">-rw-r--r-- 1 root root   5004 Mar  5 20:02 com.usebottles.bottles_2022.2.28-trento-2_amd64.changes</span><br><span class="line">-rw-r--r-- 1 root root 269408 Mar  5 20:02 com.usebottles.bottles_2022.2.28-trento-2_amd64.deb</span><br></pre></td></tr></table></figure><ol start="6"><li>安装</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install ./com.usebottles.bottles.*.deb</span><br></pre></td></tr></table></figure><ol start="7"><li>检查有没有 bottles 命令</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> bottles</span><br></pre></td></tr></table></figure><p>如果出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bottles is /usr/bin/bottles</span><br></pre></td></tr></table></figure><p>说明安装成功！</p><h2 id="启动和启动过程的问题修复"><a href="#启动和启动过程的问题修复" class="headerlink" title="启动和启动过程的问题修复"></a>启动和启动过程的问题修复</h2><p>在我这儿 bottles 安装好后运行命令并不能直接启动，会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% [1] 20:43:10 jyi@Syameimaru-Aya ~</span><br><span class="line">0 bottles</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/bottles&quot;, line 56, in &lt;module&gt;</span><br><span class="line">    from bottles import main</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/main.py&quot;, line 32, in &lt;module&gt;</span><br><span class="line">    from bottles.window import MainWindow</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/window.py&quot;, line 35, in &lt;module&gt;</span><br><span class="line">    from bottles.views.details import DetailsView</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/views/details.py&quot;, line 25, in &lt;module&gt;</span><br><span class="line">    from bottles.views.bottle_details import BottleView</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/views/bottle_details.py&quot;, line 36, in &lt;module&gt;</span><br><span class="line">    from bottles.dialogs.generic import MessageDialog</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/dialogs/generic.py&quot;, line 20, in &lt;module&gt;</span><br><span class="line">    gi.require_version(&#x27;GtkSource&#x27;, &#x27;4&#x27;)</span><br><span class="line">  File &quot;/usr/lib/python3/dist-packages/gi/__init__.py&quot;, line 129, in require_version</span><br><span class="line">    raise ValueError(&#x27;Namespace %s not available for version %s&#x27; %</span><br><span class="line">ValueError: Namespace GtkSource not available for version 4</span><br></pre></td></tr></table></figure><p>经过搜索发现这里是缺少了 <code>gir1.2-gtksource-4</code> 的库。估计是写依赖时写漏了。使用 <code>sudo apt install gir1.2-gtksource-4</code> 安装上就可以正常运行了。</p><h2 id="简易使用"><a href="#简易使用" class="headerlink" title="简易使用"></a>简易使用</h2><p>安装运行之后会出现欢迎界面，点几下 “下一步” 之后 bottles 会下载相关组件。这个很慢，可能是因为服务器在国外。多等一会儿就好了。等的时候可以写写博客之类的……</p><p>之后使用方式非常显然，所以就不写了（咕了）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bottles-安装&quot;&gt;&lt;a href=&quot;#Bottles-安装&quot; class=&quot;headerlink&quot; title=&quot;Bottles 安装&quot;&gt;&lt;/a&gt;Bottles 安装&lt;/h1&gt;&lt;h2 id=&quot;好名字！&quot;&gt;&lt;a href=&quot;#好名字！&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
</feed>
