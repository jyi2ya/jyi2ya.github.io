<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>jyi2ya 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="jyi2ya 的博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="jyi2ya 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="我的博客，用来写一些奇奇怪怪的东西。"><meta property="og:type" content="blog"><meta property="og:title" content="jyi2ya 的博客"><meta property="og:url" content="https://jyi2ya.github.io/"><meta property="og:site_name" content="jyi2ya 的博客"><meta property="og:description" content="我的博客，用来写一些奇奇怪怪的东西。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jyi2ya.github.io/img/og_image.png"><meta property="article:author" content="jyi2ya"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jyi2ya.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jyi2ya.github.io"},"headline":"jyi2ya 的博客","image":["https://jyi2ya.github.io/img/og_image.png"],"author":{"@type":"Person","name":"jyi2ya"},"publisher":{"@type":"Organization","name":"jyi2ya 的博客","logo":{"@type":"ImageObject"}},"description":"我的博客，用来写一些奇奇怪怪的东西。"}</script><link rel="alternate" href="/feed.xml" title="jyi2ya 的博客" type="application/atom+xml"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">jyi2ya 的博客</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">10 分钟读完 (大约1500个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/note/running-process-constantly-consume-disk-space/main/">对集群上 df 和 du 命令显示结果不一致的排查记录</a></p><div class="content"><h1 id="对集群上-df-和-du-命令显示结果不一致的排查记录"><a href="#对集群上-df-和-du-命令显示结果不一致的排查记录" class="headerlink" title="对集群上 df 和 du 命令显示结果不一致的排查记录"></a>对集群上 df 和 du 命令显示结果不一致的排查记录</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在集群上跑作业，然后把磁盘空间吃掉了。把占用空间很大的文件删掉后，<code>du /home</code> 命令的结果显示磁盘占用已经回到了正常水平，但是 <code>df -h</code> 显示，<code>/home</code> 所在分区的磁盘占用率还是 100%，也不能新建和修改文件。</p>
<h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><h3 id="不会是把文件系统弄坏了吧！"><a href="#不会是把文件系统弄坏了吧！" class="headerlink" title="不会是把文件系统弄坏了吧！"></a>不会是把文件系统弄坏了吧！</h3><p>仔细想了想好像不可能，因为平时都是用普通用户的身份工作的……不太可能搞出影响文件系统的操作。</p>
<h3 id="有些人的小文件太多，把-inode-给用光了！"><a href="#有些人的小文件太多，把-inode-给用光了！" class="headerlink" title="有些人的小文件太多，把 inode 给用光了！"></a>有些人的小文件太多，把 inode 给用光了！</h3><p>看起来有可能，但是回想下很久很久以前自己做赛博仓鼠的时候遇到的问题，就会发现两个问题表现完全不一样。</p>
<p>很久很久以前，赛博鼠鼠 jyi 试图往自己的鼠鼠洞里塞图片，发现没有磁盘空间了！他 <code>df</code> 了下，发现硬盘空间还有很多，但是新建文件就是会出错。他又试了试往已有的文件后面追加写入一些东西，好像可以成功。他觉得非常奇怪，“凭什么磁盘有空间，但是就是不让我放东西呢？”</p>
<p>用一种比较笨蛋的方法来看 <code>ext&#123;2,3,4&#125;</code> 文件系统，就知道文件系统中，一个文件需要 1 个 inode 和许多许多 block。其中，inode 用来存放文件的元数据，block 用来存放文件本身。由于 block 数量一般多于 inode 的数量（block 的数量少于 inode 的数量有啥用啊……），所以可能会出现 inode 耗尽，而 block 有剩余的情况。在这种情况下，无法新建文件，却可以修改文件。</p>
<p>因为赛博鼠鼠 jyi 非常菜，所以他与电脑搏斗了一番后才想起关于 inode 的知识。他 <code>df -i</code> 了一下，发现自己要存放图片的文件系统的 inode 已经用光了。最后他把一些图片打包成 sfs，再挂载到<del>世界树</del>目录树上，从而在原本的文件系统里回收了一些 inode，终于解决了这个问题。</p>
<p>回到集群上来，为什么这个表现和集群上遇到的状况完全不一样呢？因为经过检查发现，集群上显示 <code>df -i</code> 不是 100%，<code>df -h</code> 显示的使用率是 100%；而很久很久以前和自己的电脑搏斗时，<code>df -i</code> 显示的使用率是 100%，<code>df -h</code> 则是比 100 小不少的数字。</p>
<p>这说明集群上很可能不是很多小文件把 inode 用光的问题，更可能是巨大文件很简单地把 block 用光的问题。</p>
<h3 id="有一些邪恶文件藏在了黑暗角落里！"><a href="#有一些邪恶文件藏在了黑暗角落里！" class="headerlink" title="有一些邪恶文件藏在了黑暗角落里！"></a>有一些邪恶文件藏在了黑暗角落里！</h3><p>Linux 下面是可以往非空目录上挂载文件系统的，挂载后原目录里有的文件将会被遮盖掉。这些文件显然会被 <code>df</code> 统计，但是不会被 <code>du</code> 统计。</p>
<p>显然，最简单的方法就是把根目录之外的所有目录卸载，然后跑一下 <code>df</code> 和 <code>du</code>。然而，现在要操作的是运行中的系统（也许还有同学在上面跑神秘程序，那种中断了会遭遇线下真人快打的），不能这么粗暴地处理……</p>
<p>最后我找了个 tmpfs <code>/run/mnt</code>（因为根目录下没法新建文件夹做挂载点了），然后 <code>mount --bind / /run/mnt</code>。接着进 <code>/run/mnt</code> 一看，发现 <code>df</code> 和 <code>du</code> 的结果仍然不同！仍然是 <code>du</code> 很少一点，<code>df</code> 巨大无比的结果。</p>
<h2 id="破案"><a href="#破案" class="headerlink" title="破案"></a>破案</h2><p>正在自闭时，突然想起来，好像学文件系统时在懵懵懂懂的时候学到了 Linux 下 inode 结构体里，有关 <code>i_count</code> 和 <code>i_nlink</code> 的知识。其中，<code>i_count</code> 代表当前有多少个文件描述符引用了这个文件，<code>i_nlink</code> 代表这个文件在文件系统里有多少个硬链接。当且仅当 <code>i_count</code> 和 <code>i_nlink</code> 都为零时，这个 inode 和她所持有的 block 才被会释放。有没有这种可能，一个神秘邪恶，吃光了磁盘的巨大文件，它的 <code>i_nlink</code> 是 0 同时 <code>i_count</code> 非零，这样它不会被递归查看文件名的 <code>du</code> 找到，但是能被统计 block 的 <code>df</code> 给检查到呢？</p>
<p>于是使用 <code>lsof | grep deleted</code> 一查，果然有一堆坏比 Perl 程序，打开了巨大文件没关。文件的所有者是我，大小有 780G。考虑到集群上好像只有我写 Perl，所以主谋是谁应该不言自明了……</p>
<h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>使用天火圣裁发动了一次牛逼的攻击……其实是 <code>ps -u jyi</code>，把自己所有的进程，不管好比还是坏比都干掉了。然后 <code>df</code> 了几次，看着可用空间逐渐上涨。</p>
<p>问题最终解决了，可喜可贺可喜可贺。另外给好朋友说这个事时，还听说在 “进程打开了文件，但是文件不小心删掉了” 这种情况下，在进程关闭之前，可以去 <code>/proc/X/fd/Y</code> 下面把文件找回来。其中 <code>X</code> 是进程 pid，<code>Y</code> 是软链接，名字就是文件描述符，目标是被打开的文件，用 <code>cat</code> 命令就可以把文件给找回来。利用的也是 inode 释放的机制。</p>
<p>总之，Linux 真神奇啊 :3</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">12 分钟读完 (大约1801个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/note/shell-init/main/">shell 初始化</a></p><div class="content"><h1 id="shell-初始化"><a href="#shell-初始化" class="headerlink" title="shell 初始化"></a>shell 初始化</h1><p>众所周知，shell 初始化是一坨巨大的不祥之物。但是如果不了解初始化的过程的话，可能会在编写各种 rc、crontab 时被折磨。所以分享让大家试吃一下。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>login shell 是个比较古老的概念，指由 logind 验证用户身份后，便提供一个 login shell 供用户工作。这个 shell 的特殊意义在于，它和用户的会话紧紧绑定在一起，在它开始运行前与它结束运行后都会往 <code>/var/log/wtmp</code> 写入用户的登录记录。除了它以外，所有的被用户手动运行的 shell 都被视作普通的应用程序。</p>
<p>因为大家现在都在 tty7 用各种基于 X 的登录管理器，它们验证用户身份后会提供一个桌面环境，所以 login shell 的概念没啥用了。但是它的一些历史遗留问题还是可能给大家带来困惑。</p>
<p>生成一个 login shell 有两种方法：</p>
<ol>
<li>在 shell 后面加上 <code>-l</code> 参数，比如 <code>bash -l</code>。</li>
</ol>
<p>比如，这是一个 login shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 bash -l</span><br><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 logout</span><br></pre></td></tr></table></figure>

<p>而这不是一个 login shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 bash</span><br><span class="line">03:18 Syameimaru-Aya ~</span><br><span class="line">0 logout</span><br><span class="line">bash: logout: not login shell: use `exit&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>让 shell 的 <code>argv[0]</code> 以 <code>-</code> 开头。</li>
</ol>
<p>我们在通过 ssh 远程登录，或者从 ttyN 用 logind 登录时都可以获得 login shell。显然 logind 和 ssh 不应当对 shell 的参数做出假设（即不能假设自己即将运行的程序有一个 <code>-l</code> 参数）。所以他们用改 <code>argv[0]</code> 的方式来通知 shell。</p>
<p>sshd 是这么干的的 <code>ssh/session.c</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we have no command, execute the shell.  In this case, the shell</span></span><br><span class="line"><span class="comment"> * name to be passed in argv[0] is preceded by &#x27;-&#x27; to indicate that</span></span><br><span class="line"><span class="comment"> * this is a login shell.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>logind 也是这么干的（在 ttyN 里面试试这些东西）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Debian GNU/Linux bookworm/sid Syameimaru-Aya tty2</span><br><span class="line">Syameimaru-Aya login: jyi</span><br><span class="line">Password:</span><br><span class="line">Linux Syameimaru-Aya 5.19.0-2-amd64 #1 SMP PREEMPT_DYNAMIC Debian 5.19.11-1 (2022-09-24) x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Fri Sep 30 03:06:30 CST 2022 on tty2</span><br><span class="line">03:34 Syameimaru-Aya ~/tmp</span><br><span class="line">0 echo $0</span><br><span class="line">-bash</span><br></pre></td></tr></table></figure>

<h3 id="interactive-shell"><a href="#interactive-shell" class="headerlink" title="interactive shell"></a>interactive shell</h3><p>区分 interactive 与 non-interactive 的意义在于，让 shell 在给人类使用时与执行脚本时表现出不同的行为。</p>
<p>要求标准输入和标准输出都指向终端（用 <code>isatty</code> 系统调用确定）。仅在 interactive shell 里面会打印提示符，同时启用行编辑和 job control 特性，对人类十分友好！</p>
<p>这也解释了为啥用 <code>nc -l -p 2333 -e /bin/bash</code> 搞的丐版远程登录非常难用，因为这不是 interactive shell，没有方便的编辑特性。也能解释为啥 <code>echo echo hello | bash</code> 不会输出提示符而是直接输出命令结果，因为这不是 interactive shell，不会输出提示符。</p>
<p>当然，也可以用 <code>-i</code> 选项暴力启动交互模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">03:42 Syameimaru-Aya ~</span><br><span class="line">0 echo echo hello | bash -i</span><br><span class="line">    03:43 Syameimaru-Aya ~</span><br><span class="line">    0 echo hello</span><br><span class="line">    hello</span><br><span class="line">    03:43 Syameimaru-Aya ~</span><br><span class="line">    0 exit</span><br><span class="line">03:43 Syameimaru-Aya ~</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>（为了分辨命令的输出，输出部分往右缩进了一些）。</p>
<p>此时 shell 会像正常一样输出提示符，读取输出并且执行。</p>
<h2 id="不同的组合读取配置文件的区别"><a href="#不同的组合读取配置文件的区别" class="headerlink" title="不同的组合读取配置文件的区别"></a>不同的组合读取配置文件的区别</h2><p>以 bash 为例：</p>
<p>login：首先是 <code>/etc/profile</code>，接着是 <code>/etc/profile.d/*</code>，最后是 <code>~/.bash_profile</code> <code>~/.bash_login</code> <code>~/.profile</code> 三者按顺序检查，读取第一个可读的文件。（注意没有 <code>~/.bashrc</code>）在 shell 退出时，还会读取 <code>~/.bash_logout</code>。<br>non-login：不会读取任何配置。<br>interactive：依次读取 <code>/etc/bash.bashrc</code> <code>~/.bashrc</code>。<br>non-interactive：不会读取任何配置。</p>
<p>一般情况下，shell 启动时读取的配置是上列之一，并且 login 优先于 interactive。比如，如果 shell 以 login + interactive 的方式启动，则会读取 <code>/etc/profile</code>、<code>/etc/profile.d/*</code>、<code>~/.bash_profile</code>或<code>~/.bash_login</code>或<code>~/.profile</code>，但是并不会考虑 <code>/etc/bash.bashrc</code> 和 <code>~/.bashrc</code>，即使这是一个 interactive shell。</p>
<p>有个仅用于 bash 的例外是，当其以 non-login 且 non-interactive 的方式启动时，它会检查名为 <code>BASH_ENV</code> 的环境变量。如果变量值所表示的文件存在，则会读取该文件作为配置。</p>
<h2 id="这套神秘机制造成的麻烦"><a href="#这套神秘机制造成的麻烦" class="headerlink" title="这套神秘机制造成的麻烦"></a>这套神秘机制造成的麻烦</h2><h3 id="bashrc-与-bash-profile-之间的互动"><a href="#bashrc-与-bash-profile-之间的互动" class="headerlink" title="~/.bashrc 与 ~/.bash_profile 之间的互动"></a><code>~/.bashrc</code> 与 <code>~/.bash_profile</code> 之间的互动</h3><ol>
<li>login shell 不会读取 <code>~/.bashrc</code>，这使得 login shell 不能读取一些配置，很难用。为了解决这个问题，人们决定在 <code>~/.bash_profile</code> 里引用 <code>~/.bashrc</code></li>
<li>一些人会在 <code>~/.bashrc</code> 里对命令加入一些保护措施，比如 <code>alias rm=&#39;rm -I --preseve-root&#39;</code>，使得在同时删除三个以上文件时需要确认才能删除，另外，有些人可能会拿垃圾桶代替 <code>rm</code>。</li>
<li>一些脚本会以 login 的方式执行（通常是运行得非常早的脚本，甚至不能从父进程里继承 <code>PATH</code>），以保证自己能读取 <code>/etc/profile</code>，得到正确的环境变量。</li>
</ol>
<p>当这三点齐聚时，会发生什么呢？</p>
<ol>
<li>安装软件包时，本来应该被彻底删除的临时文件被不明不白地扔进了垃圾箱里，占用不知道多少的空间。</li>
<li>即使用了 <code>-y</code> 参数来避免安装时的用户输出，仍然有可能因为 <code>rm -I</code> 等命令而需要等待输入。这对一些后台执行的脚本（比如定时自动更新）来说是非常坏的，因为很可能没有用户会来输入一个 <code>y</code>。</li>
</ol>
<p>为了解决这个问题，只好在 <code>~/.bashrc</code> 前面加上这一句看起来很像魔法咒语的指令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ $- == *i* ]] || <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>……使得 bash 在读取 <code>~/.bashrc</code> 当配置文件时，如果是非交互终端则立即停止读取。</p>
<h3 id="crond-找不到命令，但是自己在终端里操作时又有"><a href="#crond-找不到命令，但是自己在终端里操作时又有" class="headerlink" title="crond 找不到命令，但是自己在终端里操作时又有"></a>crond 找不到命令，但是自己在终端里操作时又有</h3><p>为了方便描述，把这个命令叫作 lolcat</p>
<ol>
<li>有些人喜欢把 lolcat 放在 <code>~/.local/bin/</code> 里</li>
<li>有些人写 crontab 时喜欢用 lolcat（？）</li>
<li>他在 <code>~/.bashrc</code> 里面将 <code>~/.local/bin/</code> 加入到 <code>PATH</code> 中</li>
<li>crond 运行 shell 时为 non-interactive + non-login 模式</li>
</ol>
<p>会发生什么呢？</p>
<ol>
<li>当在终端里试图运行 lolcat 时，因为现有的是 interactive + non-login 模式，所以读取了 <code>~/.bashrc</code>，正确地设置了路径。</li>
<li>当在 crond 里运行 lolcat 时，因为是 non-interactive + non-login 模式，没有读取 <code>~/.bashrc</code>，<code>PATH</code> 里没有 <code>~/.local/bin</code>，找不到 lolcat</li>
</ol>
<p>所以在写 crontab 时，只好写 <code>bash -lc lolcat</code></p>
<p>不仅仅是 shell 脚本，C 中的 <code>system()</code>、Python 的 <code>os.system()</code> 以及更多类似物都会遇到这个问题。在终端里直接执行时，会从 bash 中继承 <code>PATH</code>，从而表现出正确的行为。而如果在 crond 内执行，则会出现找不到命令的问题。</p>
<h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><p>暂时没遇到……</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">6 分钟读完 (大约854个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/note/urxvt-jump-skip-scroll/main/">urxvt 跑得比 alacritty 还快，为什么呢？</a></p><div class="content"><h1 id="urxvt-跑得比-alacritty-还快，为什么呢？"><a href="#urxvt-跑得比-alacritty-还快，为什么呢？" class="headerlink" title="urxvt 跑得比 alacritty 还快，为什么呢？"></a>urxvt 跑得比 alacritty 还快，为什么呢？</h1><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>答案是 urxvt 并没有老老实实地绘制其内程序输出的每一个字符，而是通过一些非常取巧的方法，减少了屏幕渲染的内容数量。</p>
<p>具体来说，是用了以下两个优化：</p>
<ul>
<li>jump scroll：如果短时间内需要渲染很多行，那么 urxvt 仅会在收到的行能充满一屏时尝试刷新。</li>
<li>skip scroll：在 jump scroll 的基础上，限制刷新率为 60 Hz。</li>
</ul>
<p>开启这两个优化之后，urxvt 收到的很多内容实际上都被直接扔进历史记录里了，根本没在屏幕上出现过。同时，因为人的眼睛是非常低速的设备，所以即使这些内容没有在屏幕上出现，也不会影响使用体验。</p>
<p>如果禁用掉这些小优化，urxvt 的速度大概仅是 alacritty 的 1&#x2F;2 到 1&#x2F;3。</p>
<h2 id="alacritty-与-urxvt-的简介"><a href="#alacritty-与-urxvt-的简介" class="headerlink" title="alacritty 与 urxvt 的简介"></a>alacritty 与 urxvt 的简介</h2><p>urxvt 本身是个二十多年前的老东西，使用了很多奇怪的 X 特性。配置文件和 xterm 一样非常奇怪，可能是 Xorg 给世界留下的遗产之一……使用 C 和 C++ 编写，用 Perl 扩展。rxvt 的可扩展性很强，对标准支持也很好，各种 corner case 处理相对比较完善。</p>
<p>alacritty 是个很新的项目，号称要成为最快的终端。使用超级炒作语言 rust 开发，并且实现了 GPU 加速。他们一度声称自己是 “Fastest Terminal Emulator in Existence（现存最快终端）”。但是在 2020 年末的 <a target="_blank" rel="noopener" href="https://github.com/alacritty/alacritty/commit/3d7b16d4b0d867268c315f421904f3a2dc81a72d">一次提交</a> 中不知道为什么他们换了说法，甚至连大家炒作时最爱的 “Blazing Fast” 也干没了。可能是开发者开发地表最速终端的梦想在现实里撞车了。非常快乐，大家快去围观。总之，相比项目早期的自述，现在的自述温和了很多。</p>
<p>两个都是非常好的终端。我之前是在 Windows 下用 alacritty，在 Linux 下用 urxvt。</p>
<h2 id="为什么需要关注终端速度"><a href="#为什么需要关注终端速度" class="headerlink" title="为什么需要关注终端速度"></a>为什么需要关注终端速度</h2><p>……其实意义也不是很大，因为大家在输出内容太长的时候都会 <code>| less</code> 一下，用 pager 分页来看，终端速度对使用体验的影响很小。</p>
<p>但是既然速度是个能比的项目，那总会有人抱着一种宝可梦对决的心态来研究两个终端谁快谁慢，这也促进了这篇水帖的诞生！</p>
<h2 id="urxvt-的小优化相关代码"><a href="#urxvt-的小优化相关代码" class="headerlink" title="urxvt 的小优化相关代码"></a>urxvt 的小优化相关代码</h2><p>摘自 urxvt 代码仓库 <code>src/command.C</code> 的第 2267 行。</p>
<pre><code>if (ecb_unlikely (ch == C0_LF || str &gt;= eol))
  &#123;
    if (ch == C0_LF)
      nlines++;

    refresh_count++;

    if (!option (Opt_jumpScroll) || refresh_count &gt;= nrow - 1)
      &#123;
        refresh_count = 0;

        if (!option (Opt_skipScroll) || ev_time () &gt; ev::now () + 1. / 60.)
          &#123;
            refreshnow = true;
            ch = NOCHAR;
            break;
          &#125;
      &#125;
</code></pre>
<p>大概就是它用一堆错综复杂的条件变量实现了上面提到的小优化，整段代码唯一的注释的是这样的：</p>
<pre><code>/*
 * If there have been a lot of new lines, then update the screen
 * What the heck we&#39;ll cheat and only refresh less than every page-full.
 * if skipScroll is enabled.
 */
</code></pre>
<p>摆了。这啥 GNU-style 的神秘老代码看得我头疼……</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">3 分钟读完 (大约442个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/blog-image/main/">markdown 中使用图片但是不使用图床</a></p><div class="content"><h1 id="markdown-中使用图片但是不使用图床"><a href="#markdown-中使用图片但是不使用图床" class="headerlink" title="markdown 中使用图片但是不使用图床"></a>markdown 中使用图片但是不使用图床</h1><p>起因是写博客要插入图片，但是懒得上传图片到图床。经过一番尝试后发现可以把图片 base64 编码后放进 markdown 语法中本应该放图片 url 的位置，直接将图片插进 markdown 文件里。</p>
<p>显然我们需要找出 markdown 中的图片。为了减少图片大小，还需要缩放和压缩。为了偷懒想找找有没有相关的项目可以实现功能。只找到了 <a target="_blank" rel="noopener" href="https://gitee.com/hujingnb/markdownImage">markdownImage</a>。但是这个图片压缩好像是调用一些网站的 api 来完成相关功能的，还有免费次数限制，并且并不提供图片缩放功能。感觉和需求出入有点大……</p>
<p>最后我写了个便利脚本来完成这项任务，需要机器上安装了 imagemagick、base64 和 tr。</p>
<p>（这个脚本问题还是比较多，比如没有区分代码块里格式类似图片链接的部分和真正的图片链接，某些情况，比如 markdown 教程估计会锅掉。但是总之还是能用的嘛）</p>
<p>会从标准输入和命令行文件中读取内容，处理后输出到标准输出。（在后面接一个 clip 剪贴板程序就可以直接准备发布到博客园啦）</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env perl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> v5.<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">process_image</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$_ = <span class="keyword">shift</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="regexp">/\.gif$/</span>) &#123;</span><br><span class="line">		<span class="string">&quot;data:image/gif;base64,&quot;</span> .</span><br><span class="line">		<span class="string">qx &#123;</span></span><br><span class="line"><span class="string">		convert -fuzz 15% -layers Optimize \Q$_\E - | base64 | tr -d &#x27;\n&#x27;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="string">&quot;data:image/jpeg;base64,&quot;</span> .</span><br><span class="line">		<span class="string">qx &#123;</span></span><br><span class="line"><span class="string">		convert -resize \Q1280x960&gt;\E -strip -quality 75% \Q$_\E jpeg:- | base64 | tr -d &#x27;\n&#x27;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">defined</span>(<span class="keyword">my</span> $line = &lt;&gt;)) &#123;</span><br><span class="line">	<span class="keyword">for</span> ($line =~ <span class="regexp">/!\[[^\]]*\]\([^)]*\)/g</span>) &#123;</span><br><span class="line">		<span class="keyword">my</span> ($mark, $desc, $file) = <span class="regexp">/(!\[([^\]]*)\]\(([^)]*)\))/</span>;</span><br><span class="line">		$file = process_image $file;</span><br><span class="line">		$line =~ <span class="regexp">s/\Q$mark\E/![$desc]($file)/</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">print</span> $line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">11 分钟读完 (大约1723个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/canvas/main/">用盲文字符来在终端画黑白图像</a></p><div class="content"><h1 id="用盲文字符来在终端画黑白图像"><a href="#用盲文字符来在终端画黑白图像" class="headerlink" title="用盲文字符来在终端画黑白图像"></a>用盲文字符来在终端画黑白图像</h1><h2 id="食用提示"><a href="#食用提示" class="headerlink" title="食用提示"></a>食用提示</h2><p>如果这篇文章在您的设备上显示很多方框，或许是字体出了问题。请确保自己使用的字体可以正常显示盲文。</p>
<p>在我的设备上，无论怎么操作都无法使 urxvt （rxvt ， xterm ） 表现出我想要的样子。因此在不建议您进行实验时使用 urxvt （rxvt ， xterm ） 。</p>
<h2 id="想法来源"><a href="#想法来源" class="headerlink" title="想法来源"></a>想法来源</h2><p>有一天发现盲文就是一堆像素点，就想着用盲文文字在终端画图。</p>
<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lsp7f3e4.png" alt="show1.png"><br><img src="https://cdn.luogu.com.cn/upload/image_hosting/1oy9pwhi.png" alt="show2.png"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">⠀⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏</span><br><span class="line">⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟</span><br><span class="line">⠠⠡⠢⠣⠤⠥⠦⠧⠨⠩⠪⠫⠬⠭⠮⠯</span><br><span class="line">⠰⠱⠲⠳⠴⠵⠶⠷⠸⠹⠺⠻⠼⠽⠾⠿</span><br><span class="line">⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏</span><br><span class="line">⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟</span><br><span class="line">⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯</span><br><span class="line">⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿</span><br><span class="line">⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏</span><br><span class="line">⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟</span><br><span class="line">⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯</span><br><span class="line">⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿</span><br><span class="line">⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏</span><br><span class="line">⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟</span><br><span class="line">⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯</span><br><span class="line">⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿</span><br></pre></td></tr></table></figure>

<p>这是 UTF-8 中的盲文字符。共有 256 个。每个盲文字符都由数个点组成。点最多的盲文字符（右下角）有 8 个点，它看起来像个实心黑框框；点最少的盲文字符有 0 个点（左上角），虽然它看上去像个空格，但它真的和空格不是一个东西。</p>
<p>稍微观察可以发现，一个盲文字符可以当成 4x2 的小形位图使用，如果能够良好组织，使盲文字符按某种方式排列，就可以拼出大一些的位图。</p>
<p>不同的 4x2 位图共有 2^8 &#x3D; 256 个，而不同的盲文字符正好也有 256 个。这意味着盲文字符和 4x2 的位图之间有着一一对应的关系。为了方便盲文与位图的与相转化，我们需要设计一种编码方案。</p>
<p>上面列出的表显然是经过良好组织的，可以发现盲文字符的排布很有规律。找规律的过程略去不提，这里仅说编码方案。经过以下操作后，可以保证盲文字符和其对应的 4x2 位图有相同的编号：</p>
<p>盲文：将上表中的盲文从上到下，从左到右依次编号 0 到 255 。</p>
<p>位图：考虑搞一张权值表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  8</span><br><span class="line">2  16</span><br><span class="line">4  32</span><br><span class="line">64 128</span><br></pre></td></tr></table></figure>

<p>将表中所有对应位图黑色位置的权值加起来，得到的和即为位图的编号。</p>
<p>例如，字符 “⢫” ，其编号为 171 ，其位图为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure>

<p>和权值表 py 后得到 1 + 8 + 2 + 32 + 128 &#x3D; 171 ，和期待结果一致。</p>
<p>使用这个方法，可以将 4x2 的小位图和它所对应的盲文字符的编号对应起来。于是，我们就可以在终端画图了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先对盲文字符打表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *magic_table[] = &#123;</span><br><span class="line">	<span class="string">&quot;⠀&quot;</span>, <span class="string">&quot;⠁&quot;</span>, <span class="string">&quot;⠂&quot;</span>, <span class="string">&quot;⠃&quot;</span>, <span class="string">&quot;⠄&quot;</span>, <span class="string">&quot;⠅&quot;</span>, <span class="string">&quot;⠆&quot;</span>, <span class="string">&quot;⠇&quot;</span>, <span class="string">&quot;⠈&quot;</span>, <span class="string">&quot;⠉&quot;</span>, <span class="string">&quot;⠊&quot;</span>, <span class="string">&quot;⠋&quot;</span>, <span class="string">&quot;⠌&quot;</span>, <span class="string">&quot;⠍&quot;</span>, <span class="string">&quot;⠎&quot;</span>, <span class="string">&quot;⠏&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⠐&quot;</span>, <span class="string">&quot;⠑&quot;</span>, <span class="string">&quot;⠒&quot;</span>, <span class="string">&quot;⠓&quot;</span>, <span class="string">&quot;⠔&quot;</span>, <span class="string">&quot;⠕&quot;</span>, <span class="string">&quot;⠖&quot;</span>, <span class="string">&quot;⠗&quot;</span>, <span class="string">&quot;⠘&quot;</span>, <span class="string">&quot;⠙&quot;</span>, <span class="string">&quot;⠚&quot;</span>, <span class="string">&quot;⠛&quot;</span>, <span class="string">&quot;⠜&quot;</span>, <span class="string">&quot;⠝&quot;</span>, <span class="string">&quot;⠞&quot;</span>, <span class="string">&quot;⠟&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⠠&quot;</span>, <span class="string">&quot;⠡&quot;</span>, <span class="string">&quot;⠢&quot;</span>, <span class="string">&quot;⠣&quot;</span>, <span class="string">&quot;⠤&quot;</span>, <span class="string">&quot;⠥&quot;</span>, <span class="string">&quot;⠦&quot;</span>, <span class="string">&quot;⠧&quot;</span>, <span class="string">&quot;⠨&quot;</span>, <span class="string">&quot;⠩&quot;</span>, <span class="string">&quot;⠪&quot;</span>, <span class="string">&quot;⠫&quot;</span>, <span class="string">&quot;⠬&quot;</span>, <span class="string">&quot;⠭&quot;</span>, <span class="string">&quot;⠮&quot;</span>, <span class="string">&quot;⠯&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⠰&quot;</span>, <span class="string">&quot;⠱&quot;</span>, <span class="string">&quot;⠲&quot;</span>, <span class="string">&quot;⠳&quot;</span>, <span class="string">&quot;⠴&quot;</span>, <span class="string">&quot;⠵&quot;</span>, <span class="string">&quot;⠶&quot;</span>, <span class="string">&quot;⠷&quot;</span>, <span class="string">&quot;⠸&quot;</span>, <span class="string">&quot;⠹&quot;</span>, <span class="string">&quot;⠺&quot;</span>, <span class="string">&quot;⠻&quot;</span>, <span class="string">&quot;⠼&quot;</span>, <span class="string">&quot;⠽&quot;</span>, <span class="string">&quot;⠾&quot;</span>, <span class="string">&quot;⠿&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;⡀&quot;</span>, <span class="string">&quot;⡁&quot;</span>, <span class="string">&quot;⡂&quot;</span>, <span class="string">&quot;⡃&quot;</span>, <span class="string">&quot;⡄&quot;</span>, <span class="string">&quot;⡅&quot;</span>, <span class="string">&quot;⡆&quot;</span>, <span class="string">&quot;⡇&quot;</span>, <span class="string">&quot;⡈&quot;</span>, <span class="string">&quot;⡉&quot;</span>, <span class="string">&quot;⡊&quot;</span>, <span class="string">&quot;⡋&quot;</span>, <span class="string">&quot;⡌&quot;</span>, <span class="string">&quot;⡍&quot;</span>, <span class="string">&quot;⡎&quot;</span>, <span class="string">&quot;⡏&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⡐&quot;</span>, <span class="string">&quot;⡑&quot;</span>, <span class="string">&quot;⡒&quot;</span>, <span class="string">&quot;⡓&quot;</span>, <span class="string">&quot;⡔&quot;</span>, <span class="string">&quot;⡕&quot;</span>, <span class="string">&quot;⡖&quot;</span>, <span class="string">&quot;⡗&quot;</span>, <span class="string">&quot;⡘&quot;</span>, <span class="string">&quot;⡙&quot;</span>, <span class="string">&quot;⡚&quot;</span>, <span class="string">&quot;⡛&quot;</span>, <span class="string">&quot;⡜&quot;</span>, <span class="string">&quot;⡝&quot;</span>, <span class="string">&quot;⡞&quot;</span>, <span class="string">&quot;⡟&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⡠&quot;</span>, <span class="string">&quot;⡡&quot;</span>, <span class="string">&quot;⡢&quot;</span>, <span class="string">&quot;⡣&quot;</span>, <span class="string">&quot;⡤&quot;</span>, <span class="string">&quot;⡥&quot;</span>, <span class="string">&quot;⡦&quot;</span>, <span class="string">&quot;⡧&quot;</span>, <span class="string">&quot;⡨&quot;</span>, <span class="string">&quot;⡩&quot;</span>, <span class="string">&quot;⡪&quot;</span>, <span class="string">&quot;⡫&quot;</span>, <span class="string">&quot;⡬&quot;</span>, <span class="string">&quot;⡭&quot;</span>, <span class="string">&quot;⡮&quot;</span>, <span class="string">&quot;⡯&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⡰&quot;</span>, <span class="string">&quot;⡱&quot;</span>, <span class="string">&quot;⡲&quot;</span>, <span class="string">&quot;⡳&quot;</span>, <span class="string">&quot;⡴&quot;</span>, <span class="string">&quot;⡵&quot;</span>, <span class="string">&quot;⡶&quot;</span>, <span class="string">&quot;⡷&quot;</span>, <span class="string">&quot;⡸&quot;</span>, <span class="string">&quot;⡹&quot;</span>, <span class="string">&quot;⡺&quot;</span>, <span class="string">&quot;⡻&quot;</span>, <span class="string">&quot;⡼&quot;</span>, <span class="string">&quot;⡽&quot;</span>, <span class="string">&quot;⡾&quot;</span>, <span class="string">&quot;⡿&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;⢀&quot;</span>, <span class="string">&quot;⢁&quot;</span>, <span class="string">&quot;⢂&quot;</span>, <span class="string">&quot;⢃&quot;</span>, <span class="string">&quot;⢄&quot;</span>, <span class="string">&quot;⢅&quot;</span>, <span class="string">&quot;⢆&quot;</span>, <span class="string">&quot;⢇&quot;</span>, <span class="string">&quot;⢈&quot;</span>, <span class="string">&quot;⢉&quot;</span>, <span class="string">&quot;⢊&quot;</span>, <span class="string">&quot;⢋&quot;</span>, <span class="string">&quot;⢌&quot;</span>, <span class="string">&quot;⢍&quot;</span>, <span class="string">&quot;⢎&quot;</span>, <span class="string">&quot;⢏&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⢐&quot;</span>, <span class="string">&quot;⢑&quot;</span>, <span class="string">&quot;⢒&quot;</span>, <span class="string">&quot;⢓&quot;</span>, <span class="string">&quot;⢔&quot;</span>, <span class="string">&quot;⢕&quot;</span>, <span class="string">&quot;⢖&quot;</span>, <span class="string">&quot;⢗&quot;</span>, <span class="string">&quot;⢘&quot;</span>, <span class="string">&quot;⢙&quot;</span>, <span class="string">&quot;⢚&quot;</span>, <span class="string">&quot;⢛&quot;</span>, <span class="string">&quot;⢜&quot;</span>, <span class="string">&quot;⢝&quot;</span>, <span class="string">&quot;⢞&quot;</span>, <span class="string">&quot;⢟&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⢠&quot;</span>, <span class="string">&quot;⢡&quot;</span>, <span class="string">&quot;⢢&quot;</span>, <span class="string">&quot;⢣&quot;</span>, <span class="string">&quot;⢤&quot;</span>, <span class="string">&quot;⢥&quot;</span>, <span class="string">&quot;⢦&quot;</span>, <span class="string">&quot;⢧&quot;</span>, <span class="string">&quot;⢨&quot;</span>, <span class="string">&quot;⢩&quot;</span>, <span class="string">&quot;⢪&quot;</span>, <span class="string">&quot;⢫&quot;</span>, <span class="string">&quot;⢬&quot;</span>, <span class="string">&quot;⢭&quot;</span>, <span class="string">&quot;⢮&quot;</span>, <span class="string">&quot;⢯&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⢰&quot;</span>, <span class="string">&quot;⢱&quot;</span>, <span class="string">&quot;⢲&quot;</span>, <span class="string">&quot;⢳&quot;</span>, <span class="string">&quot;⢴&quot;</span>, <span class="string">&quot;⢵&quot;</span>, <span class="string">&quot;⢶&quot;</span>, <span class="string">&quot;⢷&quot;</span>, <span class="string">&quot;⢸&quot;</span>, <span class="string">&quot;⢹&quot;</span>, <span class="string">&quot;⢺&quot;</span>, <span class="string">&quot;⢻&quot;</span>, <span class="string">&quot;⢼&quot;</span>, <span class="string">&quot;⢽&quot;</span>, <span class="string">&quot;⢾&quot;</span>, <span class="string">&quot;⢿&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;⣀&quot;</span>, <span class="string">&quot;⣁&quot;</span>, <span class="string">&quot;⣂&quot;</span>, <span class="string">&quot;⣃&quot;</span>, <span class="string">&quot;⣄&quot;</span>, <span class="string">&quot;⣅&quot;</span>, <span class="string">&quot;⣆&quot;</span>, <span class="string">&quot;⣇&quot;</span>, <span class="string">&quot;⣈&quot;</span>, <span class="string">&quot;⣉&quot;</span>, <span class="string">&quot;⣊&quot;</span>, <span class="string">&quot;⣋&quot;</span>, <span class="string">&quot;⣌&quot;</span>, <span class="string">&quot;⣍&quot;</span>, <span class="string">&quot;⣎&quot;</span>, <span class="string">&quot;⣏&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⣐&quot;</span>, <span class="string">&quot;⣑&quot;</span>, <span class="string">&quot;⣒&quot;</span>, <span class="string">&quot;⣓&quot;</span>, <span class="string">&quot;⣔&quot;</span>, <span class="string">&quot;⣕&quot;</span>, <span class="string">&quot;⣖&quot;</span>, <span class="string">&quot;⣗&quot;</span>, <span class="string">&quot;⣘&quot;</span>, <span class="string">&quot;⣙&quot;</span>, <span class="string">&quot;⣚&quot;</span>, <span class="string">&quot;⣛&quot;</span>, <span class="string">&quot;⣜&quot;</span>, <span class="string">&quot;⣝&quot;</span>, <span class="string">&quot;⣞&quot;</span>, <span class="string">&quot;⣟&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⣠&quot;</span>, <span class="string">&quot;⣡&quot;</span>, <span class="string">&quot;⣢&quot;</span>, <span class="string">&quot;⣣&quot;</span>, <span class="string">&quot;⣤&quot;</span>, <span class="string">&quot;⣥&quot;</span>, <span class="string">&quot;⣦&quot;</span>, <span class="string">&quot;⣧&quot;</span>, <span class="string">&quot;⣨&quot;</span>, <span class="string">&quot;⣩&quot;</span>, <span class="string">&quot;⣪&quot;</span>, <span class="string">&quot;⣫&quot;</span>, <span class="string">&quot;⣬&quot;</span>, <span class="string">&quot;⣭&quot;</span>, <span class="string">&quot;⣮&quot;</span>, <span class="string">&quot;⣯&quot;</span>,</span><br><span class="line">	<span class="string">&quot;⣰&quot;</span>, <span class="string">&quot;⣱&quot;</span>, <span class="string">&quot;⣲&quot;</span>, <span class="string">&quot;⣳&quot;</span>, <span class="string">&quot;⣴&quot;</span>, <span class="string">&quot;⣵&quot;</span>, <span class="string">&quot;⣶&quot;</span>, <span class="string">&quot;⣷&quot;</span>, <span class="string">&quot;⣸&quot;</span>, <span class="string">&quot;⣹&quot;</span>, <span class="string">&quot;⣺&quot;</span>, <span class="string">&quot;⣻&quot;</span>, <span class="string">&quot;⣼&quot;</span>, <span class="string">&quot;⣽&quot;</span>, <span class="string">&quot;⣾&quot;</span>, <span class="string">&quot;⣿&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着实现 canvas 结构体。这里用 <code>unsigned char</code> 数组当成 <code>bool</code> 数组使用。日后优化时，可以用 bitmap 节省空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">canvas</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="type">void</span> *buf;</span><br><span class="line">&#125; canvas;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">canvas_init</span><span class="params">(canvas *p, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line">	width = ((width - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">	height = ((height - <span class="number">1</span>) / <span class="number">4</span> + <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">	p-&gt;width = width;</span><br><span class="line">	p-&gt;height = height;</span><br><span class="line">	p-&gt;buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) * width * height);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;buf == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canvas_clear</span><span class="params">(canvas p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(p.buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现画像素点和打印功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">canvas_draw</span><span class="params">(canvas p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	((<span class="type">unsigned</span> <span class="type">char</span> (*)[p.width])p.buf)[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canvas_erase</span><span class="params">(canvas p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	((<span class="type">unsigned</span> <span class="type">char</span> (*)[p.width])p.buf)[y][x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">canvas_test</span><span class="params">(canvas p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">char</span> (*)[p.width])p.buf)[y][x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canvas_print</span><span class="params">(canvas p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k, l;</span><br><span class="line">	<span class="keyword">for</span> (i = p.height; i &gt; <span class="number">0</span>; i -= <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; p.width; j += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (l = <span class="number">1</span>; l &gt;= <span class="number">0</span>; --l)</span><br><span class="line">				<span class="keyword">for</span> (k = <span class="number">3</span>; k &gt;= <span class="number">1</span>; --k)</span><br><span class="line">					id = (id &lt;&lt; <span class="number">1</span>) | canvas_test(p, j + l, i - k);</span><br><span class="line">			<span class="keyword">if</span> (canvas_test(p, j, i - <span class="number">4</span>))</span><br><span class="line">				id += <span class="number">64</span>;</span><br><span class="line">			<span class="keyword">if</span> (canvas_test(p, j + <span class="number">1</span>, i - <span class="number">4</span>))</span><br><span class="line">				id += <span class="number">128</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, magic_table[id]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现完成。以下是函数功能与参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int canvas_init(canvas *p, int width, int height); 将 p 初始化为宽 width 高 height 的画布</span><br><span class="line">void canvas_clear(canvas p); 销毁画布 p</span><br><span class="line">void canvas_draw(canvas p, int x, int y); 在 p 的 (x, y) 位置画上一个像素点</span><br><span class="line">void canvas_erase(canvas p, int x, int y); 擦除 p 中 (x, y) 位置上的像素点</span><br><span class="line">int canvas_test(canvas p, int x, int y); 返回 p 中 (x, y) 上是否已经画过</span><br><span class="line">void canvas_print(canvas p); 打印 p</span><br></pre></td></tr></table></figure>

<h2 id="实现示例中的效果"><a href="#实现示例中的效果" class="headerlink" title="实现示例中的效果"></a>实现示例中的效果</h2><p>用 ImageMagick 的 convert 命令将图片文件转为只有 2 种颜色的 xpm 文件，写个傻瓜 xpm 解析器，配合上面的代码简单处理即可得到示例中的效果。傻瓜解析器的代码见：<a target="_blank" rel="noopener" href="https://www.luogu.org/paste/npaqkp89">doxpm.c</a> 。</p>
<p>在本机上，实现示例效果的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ convert -colors 2 sample.png a.xpm</span><br><span class="line">$ gcc doxpm.c -o doxpm</span><br><span class="line">$ ./doxpm</span><br><span class="line">$ <span class="comment"># 如果需要彩色的话：</span></span><br><span class="line">$ ./doxpm | lolcat</span><br></pre></td></tr></table></figure>

<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>代码仅被用来说明想法，并没有想写成一个可用的库。所以码风略快糙猛请多包涵。</p>
<p>感谢 zrz_orz 同学教我在洛谷日报上投稿，并提出大量修改意见。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">6 分钟读完 (大约833个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/complete-alias/main/">使用 complete-alias 补全 bash 别名的参数</a></p><div class="content"><h1 id="使用-complete-alias-补全-bash-别名的参数"><a href="#使用-complete-alias-补全-bash-别名的参数" class="headerlink" title="使用 complete-alias 补全 bash 别名的参数"></a>使用 complete-alias 补全 bash 别名的参数</h1><h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>众所周知，bash 中有个很方便的功能，使用 <code>alias</code> 命令创建命令别名。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git</span></span><br><span class="line"><span class="built_in">alias</span> cg=<span class="string">&#x27;cd `git rev-parse --show-toplevel || echo .`&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gaA=<span class="string">&#x27;git add -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gad=<span class="string">&#x27;git add&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gbc=<span class="string">&#x27;git branch&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcm=<span class="string">&#x27;git commit&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gco=<span class="string">&#x27;git checkout&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gst=<span class="string">&#x27;git status&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcl=<span class="string">&#x27;git clone&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> glg=<span class="string">&#x27;git log --graph&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gmg=<span class="string">&#x27;git merge&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gdf=<span class="string">&#x27;git diff&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样，如果我们输入 <code>gcl</code>，bash 就会认为我们输入的是 <code>git clone</code>。极大地减少了输入字母的数量。</p>
<h2 id="命令参数补全"><a href="#命令参数补全" class="headerlink" title="命令参数补全"></a>命令参数补全</h2><p>bash 还有另一个强大的功能，命令参数补全。这个命令参数补全不仅仅是补全当前目录下的文件，而是根据当前已经输入的命令和参数，猜测补全下一个参数。一般来说发行版都会提供大量写好的补全脚本，可以直接使用。</p>
<p>以 Debian 为例，安装 <code>bash-completion</code> 软件包后，在 <code>~/.bashrc</code> 中加上 <code>source /etc/bash_completion</code>。接着输入命令，连续按下两下 <code>tab</code> 键就可以触发补全功能（按下 <code>tab</code> 键的地方在下面用 <code>&lt;TAB&gt;</code> 表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% 19:50:08 (master) ~/sr/md/bl/note/complete-alias</span><br><span class="line">0 ls --h&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">--help                --hide-control-chars  --hyperlink</span><br><span class="line">--hide=               --human-readable</span><br></pre></td></tr></table></figure>

<p>虽然说没有 zsh 的好用就是啦。</p>
<h2 id="但是有一个小问题"><a href="#但是有一个小问题" class="headerlink" title="但是有一个小问题"></a>但是有一个小问题</h2><p>bash 的命令参数补全是根据命令名来确定的，举一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">_id</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> cur prev words cword</span><br><span class="line">    _init_completion || <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$cur</span> == -* ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> opts=$(_parse_help <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line">        [[ <span class="variable">$opts</span> ]] || opts=<span class="string">&quot;-G -g -u&quot;</span> <span class="comment"># POSIX fallback</span></span><br><span class="line">        COMPREPLY=($(compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="string">&quot;<span class="variable">$cur</span>&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        COMPREPLY=($(compgen -u <span class="string">&quot;<span class="variable">$cur</span>&quot;</span>))</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125; &amp;&amp;</span><br><span class="line">    complete -F _id <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>这是从 <code>/usr/share/bash-completion/completions/id</code> 里面摘抄的补全相关代码。可以看到，代码里先实现了 shell 函数 <code>_id</code>，再用 <code>complete -F _id id</code> 来把 <code>id</code> 命令相关的补全和 <code>_id</code> 绑定在一起。即需要补全 <code>id</code> 命令的参数时，会用某种方式调用 <code>_id</code> 函数。</p>
<p>这样确实可以处理很多情况，但是对别名无效。比如我们运行 <code>alias gco=&#39;git checkout&#39;</code>，把 <code>gco</code> 作为 <code>git checkout</code> 的别名。当我们输入 <code>gco</code> 再按 <code>tab</code> 键时，因为没有绑定 <code>gco</code> 相关的补全函数，所以 bash 不知道如何补全，只能在后面接上文件名。</p>
<p>我们期待的行为应该是输入 <code>gco</code> 再按 <code>tab</code> 就和输入 <code>git checkout</code> 再按 <code>tab</code> 一样，可以补全出分支名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% 20:03:23 (master) ~/sr/md/bl/note/complete-alias</span><br><span class="line">0 git checkout&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">HEAD                 linux-csharp-build   master               ORIG_HEAD</span><br></pre></td></tr></table></figure>

<h2 id="小问题解决了"><a href="#小问题解决了" class="headerlink" title="小问题解决了"></a>小问题解决了</h2><p>之前肯定也有人遇到过一样的问题，并且造了相关的轮子。这儿有一个好用的：<a target="_blank" rel="noopener" href="https://github.com/cykerway/complete-alias">complete-alias</a>。</p>
<p>我们只要把仓库里面 <code>complete_alias</code> 文件中的内容复制下来，贴到 <code>~/.bashrc</code> 尾巴上（有 1000 多行，有点野蛮。讲究的人可以把它放到某个目录里然后 <code>.bashrc</code> 里面用 <code>source</code> 命令处理？），再把最后一行 <code>#complete -F _complete_alias &quot;$&#123;!BASH_ALIASES[@]&#125;&quot;</code> 前面的井号 <code>#</code> 删掉就算配置完成。重新启动 bash 即可使用。</p>
<p>总而言之挺开箱即用的，配置不费劲。</p>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% 20:14:27 (master) ~/sr/md/bl/note/complete-alias</span><br><span class="line">0 gco&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">HEAD                 linux-csharp-build   master               ORIG_HEAD</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">23 分钟读完 (大约3414个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/hyperfine/main/">hyperfine 使用指南</a></p><div class="content"><h1 id="hyperfine-使用指南"><a href="#hyperfine-使用指南" class="headerlink" title="hyperfine 使用指南"></a>hyperfine 使用指南</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>测量程序运行耗时是一个常见的需求。</p>
<p>我们经常会调整自己编写的程序，来给程序加速。但是自己提出的加速计划，不一定会被<br>机器认可。比如，你觉得 <code>++i</code> 比 <code>i++</code> 更快并且花了两天时间把程序里所有的后缀全<br>改成了前缀，但是机器不管，她编译的时候直接把你的写法给扬掉了。这个时候再在 git<br>的提交信息里写 <code>perf: 优化 XX 部分性能</code> 就会显得非常滑稽。所以，我们经常需要对<br>程序性能测试来保证自己的优化是有效的。对程序性能测试的最常用的方法就是计时。</p>
<p>小时候幼儿园的老师经常教育我们，在 <a target="_blank" rel="noopener" href="https://manpages.debian.org/buster/bash/bash.1.en.html">bash</a> 里面用 <code>time</code> 的命令就可以测量程序<br>运行的时间。这也是大家最常用的方法。但是我们都知道，<code>time</code> 是一个非常粗糙的工<br>具。用它测量程序性能时，总会遇到这么几个问题：</p>
<ul>
<li>测量出来的时间真的是准的吗？会不会受到系统波动的影响？</li>
<li>测量出来的时间有多可靠？该怎么知道测量误差？</li>
<li>我能比较轻松地对比两个或多个程序的性能吗？</li>
</ul>
<p>我们可以通过写一堆土制脚本来解决上述问题，但是与其费心写功能不全、漏洞百出的脚<br>本，还不如直接使用已有的趁手工具。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sharkdp/hyperfine">hyperfine</a> 就是一个优秀的性能测试工具。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>根据 hyperfine 自己的 <a target="_blank" rel="noopener" href="https://github.com/sharkdp/hyperfine/blob/master/README.md">介绍</a> ，hyperfine 拥有如下功能：</p>
<ul>
<li>多次测量并统计均值方差</li>
<li>支持任意 shell 命令</li>
<li>进度条和预估剩余时间</li>
<li>预热：正式测试之前先运行几次</li>
<li>测试之前执行指定命令（可用于清除缓存）</li>
<li>自动发现 cache 影响和系统性能波动影响</li>
<li>多种输出格式，支持 CSV、JSON、Markdown 等等</li>
<li>跨平台</li>
</ul>
<p>（注：hyperfine 的介绍是有 <a target="_blank" rel="noopener" href="https://github.com/chinanf-boy/hyperfine-zh">中文翻译</a> 的，但是我看的时候它略微有些过时了。<br>希望有好心人来更新一下翻译）</p>
<p>它的使用截图如下：</p>
<p><img src="https://camo.githubusercontent.com/88a0cb35f42e02e28b0433d4b5e0029e52e723d8feb8df753e1ed06a5161db56/68747470733a2f2f692e696d6775722e636f6d2f7a31394f5978452e676966" alt="hyperfine"></p>
<p>个人评测：life-changing 的好东西，我现在没有 hyperfine 都不会测程序了。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>hyperfine 的使用方式非常符合直觉，命令行结构和选项设计得很好。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>hyperfine 是用 <a target="_blank" rel="noopener" href="https://www.rust-lang.org/">rust</a> 写的（不打算去学一下？）。如果机器上有 rust 开发环境，<br>直接运行 <code>cargo install hyperfine</code> 即可完成安装。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/">cargo</a> 是 rust 的编译系统<br>和依赖管理工具。</p>
<p>如果机器上没有 rust 开发环境，可以求助你的包管理器，或者从<br><a target="_blank" rel="noopener" href="https://github.com/sharkdp/hyperfine/releases">hyperfine 在 Github 上的发布页面</a> 中，下载与自己的机器架构对应的二进制<br>文件。</p>
<h3 id="测试单个程序"><a href="#测试单个程序" class="headerlink" title="测试单个程序"></a>测试单个程序</h3><p>命令：</p>
<pre><code>hyperfine &#39;hexdump file&#39;
</code></pre>
<p>结果：</p>
<pre><code>11:17 jyi-station ~/tmp/bgifile
0 hyperfine &#39;hexdump test13.c&#39;
Benchmark 1: hexdump test13.c
  Time (mean ± σ):     385.0 ms ±   5.1 ms    [User: 383.0 ms, System: 2.1 ms]
  Range (min … max):   381.6 ms … 398.9 ms    10 runs
</code></pre>
<p>从结果可以看出，hyperfine 把程序运行了 10 次。测量出来平均耗时是 385 ms，误差<br>是 5.1 ms。运行的时候，hyperfine 把程序的所有输出重定向到了 <code>/dev/null</code> 里，所<br>以终端上没有多余的内容。</p>
<p>你看，我几乎什么都没做，只是把命令提供给 hyperfine，她就自动帮忙把所有东西都测<br>好了！</p>
<p>我们甚至无需检查误差是否过大，因为 hyperfine 会自动检测误差过大的情况，并且根<br>据程序运行时间的特征来猜测可能发生了什么问题，并给出一些建议。非常贴心。后面会<br>详细讨论这些细节。</p>
<h3 id="对比测试多个程序"><a href="#对比测试多个程序" class="headerlink" title="对比测试多个程序"></a>对比测试多个程序</h3><p>命令：</p>
<pre><code>hyperfine &#39;hexdump test13.c&#39; &#39;xxd test13.c&#39; &#39;xxd test14.c&#39;
</code></pre>
<p>结果：</p>
<pre><code>11:24 jyi-station ~/tmp/bgifile
0 hyperfine &#39;hexdump test13.c&#39; &#39;xxd test13.c&#39; &#39;xxd test14.c&#39;
Benchmark 1: hexdump test13.c
  Time (mean ± σ):     383.6 ms ±   1.9 ms    [User: 381.8 ms, System: 1.6 ms]
  Range (min … max):   381.6 ms … 387.7 ms    10 runs

Benchmark 2: xxd test13.c
  Time (mean ± σ):      90.2 ms ±   1.0 ms    [User: 88.4 ms, System: 1.9 ms]
  Range (min … max):    88.7 ms …  93.4 ms    32 runs

Benchmark 3: xxd test14.c
  Time (mean ± σ):     180.2 ms ±   2.8 ms    [User: 176.8 ms, System: 3.2 ms]
  Range (min … max):   177.1 ms … 186.6 ms    16 runs

Summary
  &#39;xxd test13.c&#39; ran
    2.00 ± 0.04 times faster than &#39;xxd test14.c&#39;
    4.25 ± 0.05 times faster than &#39;hexdump test13.c&#39;
</code></pre>
<p>在这个例子里，我们给了 hyperfine 三个参数，让她测量三个程序的耗时。hyperfine<br>首先输出了三个程序各自的运行结果，这部分和测试单个程序时的结果差不多。但是在报<br>告的最后，hyperfine 还额外给出了一些信息。她指出了跑的最快的程序（港记程序 :P）<br>，并且显示了其相对其他程序的加速比和误差。</p>
<p>我们一般测试程序时只需要关注最后的 “Summary” 一栏，知道哪个更快、快多少就可以<br>了。前面几行是和别人吵架时，给他们看测试结果让他们闭嘴时用的。</p>
<h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p>对每个程序，hyperfine 会把它运行 10 次（运行次数有选项可以配置）。hyperfine 会<br>对运行时间计时，并且求出均值和标准差。</p>
<p>每次运行的时候，hyperfine 会运行一个 shell 来执行这些程序。比如，假定程序<br>是 <code>sleep 1</code>，那么 hyperfine 实际运行的是 <code>sh -c &#39;sleep 1&#39;</code>。这种用 shell 来运<br>行程序的行为，会导致程序运行时间测量结果偏大；但是如果不用 shell 来运行程序，<br>大家平时习惯的 <code>~/</code> 和 <code>*.txt</code> 这些便利缩写就不能用了，非常麻烦。</p>
<p>总之，这种使用 shell 来执行参数的设计，算是便利与准确之间的一种折衷。</p>
<p>为了使测量结果更精确，你可以手动禁止 hyperfine 使用 shell 来执行程序的行为。<br>hyperfine 本身也会检测 shell 对测量结果的影响，并且在她觉得 shell 对测量结果的<br>影响已经大到不可忽略时提出警告。判定规则与细节将在之后描述。</p>
<h2 id="使用进阶"><a href="#使用进阶" class="headerlink" title="使用进阶"></a>使用进阶</h2><p>现在，你已经基本学会用 hyperfine 了！让我们来看看一些更好玩的东西吧。</p>
<h3 id="测试-IO-密集型程序"><a href="#测试-IO-密集型程序" class="headerlink" title="测试 IO 密集型程序"></a>测试 IO 密集型程序</h3><p>假设我们要运行一个大量读写磁盘文件的程序 10 次，我们会发现什么怪现象呢？我们<br>会发现，第一次或前几次运行所花费的时间会显著大于后面几次。这是由于 Linux 系统<br>有 Page Cache 的机制，它会尽可能努力地把最近使用过的文件缓存在内存里。</p>
<p>在第一次运行的时候，程序试图读文件。操作系统发现内存里没有相关文件，只好老老实<br>实地从磁盘上把文件读出来再交给程序。但是紧接着程序运行第二三四次，程序试图读文<br>件时，操作系统发现文件刚刚才被读过，还被缓存在内存里，于是直接把内存中的内容交<br>给程序，直接省略掉了读盘的过程。众所周知，内存的读写速度一般远大于硬盘。这导致<br>了第二三四次运行程序时，程序用时会显著少于第一次。</p>
<p>类似的情况还会出现在很多具有缓存机制的系统（没有特指操作系统！）里。在对于这些<br>系统打交道的程序计时时，我们需要给 hyperfine 加一些参数。</p>
<h4 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h4><p>我们可以使用 <code>--warmup N</code> 的参数让程序被真正计时之前，先运行 N 次，其中 N 是一<br>个整数。比如，<code>hyperfine --warmup 2 sleep 3</code> 这个命令实际上会运行 <code>sleep 3</code> 这<br>个命令 12 次，其中最后 10 次会被计时。</p>
<p>这种方式有利于将程序需要用到的东西提前装到缓存里。可以测量程序在缓存工作良好时<br>的运行效率。</p>
<h4 id="提前执行指令"><a href="#提前执行指令" class="headerlink" title="提前执行指令"></a>提前执行指令</h4><p>我们可以使用 <code>--prepare X</code> 的参数让 hyperfine 每次运行程序之前，先运行一下 X，<br>其中 X 是一条 shell 命令。比如，<br><code>hyperfine --prepare &#39;echo 3 | sudo tee /proc/sys/vm/drop_caches&#39; sleep 3</code><br>这个命令，会运行 <code>sleep 3</code> 10 次，但是每次运行前，会运行<br><code>echo 3 | sudo tee /proc/sys/vm/drop_caches</code> 一次，来清除 Linux 的 Page Cache。</p>
<p>这种方式直接让缓存没用了。可以测量程序冷启动的速度。</p>
<h3 id="测试运行时间过短的程序"><a href="#测试运行时间过短的程序" class="headerlink" title="测试运行时间过短的程序"></a>测试运行时间过短的程序</h3><p>之前说到，hyperfine 会用一个 shell 来执行待计时的程序。但是如果程序跑得很快，<br>导致 shell 启动、解析、执行的时间已经占总用时不小的一部分了，那么测量误差就会<br>变得不可接受。</p>
<p>这个时候我们就可以使用 <code>-N</code> 参数来制止 hyperfine 使用 shell。此时，她会用一个<br>内置的简陋的解析器来把命令的可执行文件和参数给分开。这个简陋的解析器主要使用<br>空白字符来分割参数，但是也支持基础的转义字符和引号。</p>
<p>比如：</p>
<pre><code>hyperfine -N &#39;touch x&#39;
</code></pre>
<h3 id="不知道自己的程序属于哪种类型？"><a href="#不知道自己的程序属于哪种类型？" class="headerlink" title="不知道自己的程序属于哪种类型？"></a>不知道自己的程序属于哪种类型？</h3><p>有笨比……</p>
<p>如果你不知道你的程序要跑多久，也不知道它是不是要用到某种缓存系统，直接把它当成<br>纯计算的程序来测就行了。hyperfine 会在发现不对劲时来提醒你。</p>
<p>下面是几个例子：</p>
<h4 id="奇怪的测量结果"><a href="#奇怪的测量结果" class="headerlink" title="奇怪的测量结果"></a>奇怪的测量结果</h4><pre><code>20:21 jyi-station ~/tmp/bgifile
0 hyperfine &#39;cat test18.c&#39;
Benchmark 1: cat test18.c
  Time (mean ± σ):      16.9 ms ±   1.0 ms    [User: 1.1 ms, System: 15.9 ms]
  Range (min … max):    15.7 ms …  22.1 ms    154 runs

  Warning: Statistical outliers were detected. Consider re-running this
  benchmark on a quiet system without any interferences from other programs.
  It might help to use the &#39;--warmup&#39; or &#39;--prepare&#39; options.
</code></pre>
<p>hyperfine 发现测试的时候，有些数据与别的明显不在一个等级。所以她警告你并且建议<br>你在系统闲的时候重跑。</p>
<h4 id="初次测量很慢"><a href="#初次测量很慢" class="headerlink" title="初次测量很慢"></a>初次测量很慢</h4><pre><code>20:21 jyi-station ~/tmp/bgifile
0 hyperfine &#39;cat test19.c&#39;
Benchmark 1: cat test19.c
  Time (mean ± σ):      34.3 ms ±  14.1 ms    [User: 2.2 ms, System: 31.8 ms]
  Range (min … max):    30.4 ms … 105.4 ms    28 runs

  Warning: The first benchmarking run for this command was significantly slower
  than the rest (105.4 ms). This could be caused by (filesystem) caches that
  were not filled until after the first run. You should consider using the
  &#39;--warmup&#39; option to fill those caches before the actual benchmark.
  Alternatively, use the &#39;--prepare&#39; option to clear the caches before each
  timing run.
</code></pre>
<p>这次 hyperfine 不仅发现数据异常，还发现是第一次跑的时候数据异常。于是她猜测是<br>某种神秘的缓存系统起了作用，并且建议你用 <code>--warmup</code> 参数或 <code>--prepare</code> 参数来<br>消除缓存的影响。</p>
<h4 id="程序跑得很快"><a href="#程序跑得很快" class="headerlink" title="程序跑得很快"></a>程序跑得很快</h4><pre><code>20:21 jyi-station ~/tmp/bgifile
0 hyperfine &#39;cat test1.c&#39;
Benchmark 1: cat test1.c
  Time (mean ± σ):       0.9 ms ±   0.1 ms    [User: 0.7 ms, System: 0.4 ms]
  Range (min … max):     0.7 ms …   1.3 ms    1340 runs

  Warning: Command took less than 5 ms to complete. Note that the results
  might be inaccurate because hyperfine can not calibrate the shell startup
  time much more precise than this limit. You can try to use the
  `-N`/`--shell=none` option to disable the shell completely.
</code></pre>
<p>这次，hyperfine 发现程序跑得很快，误差会比较大，并且建议你用 <code>-N</code> 参数来直接运行程序，<br>绕过启动 shell 的步骤。</p>
<h3 id="额外的功能"><a href="#额外的功能" class="headerlink" title="额外的功能"></a>额外的功能</h3><p>除此之外，hyperfine 还有一些别的功能，比如参数化测试之类的东西。不过我感觉要参<br>数化的话与其用这一坨命令行参数，不如去写一个小小脚本……所以我没用过。如果有人感<br>兴趣的话可以试试。</p>
<h2 id="改变输出格式以便与其他软件协作"><a href="#改变输出格式以便与其他软件协作" class="headerlink" title="改变输出格式以便与其他软件协作"></a>改变输出格式以便与其他软件协作</h2><p>hyperfine 的命令行界面很好看，有进度条还有颜色。在除命令行之外的地方，她也做得<br>很好。比如，hyperfine 可以直接用 <code>--export-markdown</code> 参数生成 markdown 表格，<br>接着你就可以直接把结果插进 README 里面。她还可以导出 json 格式的测试结果，方便<br>之后再用脚本处理，做些可视化什么的（hyperfine 的仓库就附带了许多可视化脚本，很<br>好玩）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测量程序性能的方式有很多。相比那些在函数调用上插桩（gprof）或读 PMC 寄存器<br>（perf）的东西来说，单纯的计时也许太简陋了一些。但是第一次参观 profiler，却并<br>不觉得震撼。因为我早已遇见，独属于我的 benchmarking tool。初遇你的那天起，齿轮<br>便开始转动，却无法阻止丧失的预感。尽管已经拥有了很多，但让我们再多加一个吧。<br>可以给我最后一个加速比吗？我不愿遗忘</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">17 分钟读完 (大约2536个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/shell-abbr/main/">一些能够节省按键次数的 bash 配置</a></p><div class="content"><h1 id="一些能够节省按键次数的-bash-配置"><a href="#一些能够节省按键次数的-bash-配置" class="headerlink" title="一些能够节省按键次数的 bash 配置"></a>一些能够节省按键次数的 bash 配置</h1><p>众所周知，敲击键盘的同时，人的手指会经历一系列的磨损。长此以往，手指就会变短。为了保护手指，使用下面的 bash 配置，成为和我一样能少按键盘就少按键盘的人吧！</p>
<h2 id="给命令起单个字符的别名"><a href="#给命令起单个字符的别名" class="headerlink" title="给命令起单个字符的别名"></a>给命令起单个字符的别名</h2><p>对于一些常用的命令，如果没有重复命令，可以给他们起单个字符的别名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> a=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> g=<span class="string">&#x27;grep&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> j=<span class="string">&#x27;jobs -l&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> o=<span class="string">&#x27;xdg-open&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> r=<span class="string">&#x27;rm&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> t=<span class="string">&#x27;task&#x27;</span> <span class="comment"># taskwarrior: 一个 todo-list 小软件</span></span><br><span class="line"><span class="built_in">alias</span> v=<span class="string">&#x27;vi&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -- -=<span class="string">&#x27;cd -&#x27;</span> <span class="comment"># 这里的意思是将 - 作为 cd - 的别名</span></span><br></pre></td></tr></table></figure>

<p>但是这些写法在 xargs 这里出了点小问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% 17:51:28 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 alias x=&#x27;xargs&#x27;</span><br><span class="line">% 17:51:32 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 l|x g hello</span><br><span class="line">xargs: g: No such file or directory</span><br></pre></td></tr></table></figure>

<p>我们的本意是想让它运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | xargs grep hello</span><br></pre></td></tr></table></figure>

<p>但由于 <code>g</code> 并不是命令，xargs 报了错。要是我们想让 <code>x</code> 被展开为 <code>xargs</code> 后，其后的 <code>g</code> 继续被展开，我们可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> x=<span class="string">&#x27;xargs &#x27;</span> <span class="comment"># 注意，xargs 与第二个单引号之间有一个空格</span></span><br></pre></td></tr></table></figure>

<p>之后再运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 17:58:29 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">1 l</span><br><span class="line">a.md</span><br><span class="line">% 17:58:30 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">1 l|x g &#x27;`xargs`&#x27;</span><br><span class="line">由于 `g` 并不是命令，xargs 报了错。要是我们想让 `x` 被展开为 `xargs` 后，其后的 `g` 继续被展开，我们可以这样写：</span><br></pre></td></tr></table></figure>

<p>就好了。这是 bash 的小特性，结尾的空格可以让下一个标识符展开（如果是别名的话）。同理，我们对 <code>sudo</code> 也做类似的事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> s=<span class="string">&#x27;sudo &#x27;</span></span><br></pre></td></tr></table></figure>

<p>太方便辣！</p>
<p>此外，单个 <code>%</code> 的作用和 <code>fg</code> 相同，都是让后台进程回到前台。</p>
<h2 id="给有歧义的命令们起一样的名字"><a href="#给有歧义的命令们起一样的名字" class="headerlink" title="给有歧义的命令们起一样的名字"></a>给有歧义的命令们起一样的名字</h2><p>我日常使用 <code>find</code> 和 <code>file</code> 比较频繁，正常人在缩写他们时，都会想到用 <code>f</code> 来作为它们的别名。而如果一个用 <code>f</code> 作了别名，另一个就只能用其他奇奇怪怪的缩写。有没有办法让它们共用一个名字呢？</p>
<p>由于脑机接口尚未开发完成，shell 无法通过魔法装置读取我们的思想，知道我们在运行 <code>f</code> 时究竟是想运行 <code>find</code>，还是 <code>file</code>，我们只能手动实现一个 shell 函数，根据上下文猜测输入时究竟想要什么。</p>
<p>（怎么有种 Perl 猜代码块和匿名哈希的感觉）</p>
<p>这是一个简单的示例，可以根据实际使用情况另作调整。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find, file</span></span><br><span class="line"><span class="function"><span class="title">f</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">local</span> i</span><br><span class="line">	<span class="built_in">local</span> expect_find=</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 如果发现身处管道之中，stdin 里不是终端，有输入，则猜测想要</span></span><br><span class="line">	<span class="comment"># 确定 stdin 中文件的类型</span></span><br><span class="line">	<span class="keyword">if</span> ! [ -t 0 ]; <span class="keyword">then</span></span><br><span class="line">		file -</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 如果 stdin 是终端，但是没有参数，猜测是想要递归列出当前目录</span></span><br><span class="line">	<span class="comment"># 下的文件，调用 find</span></span><br><span class="line">	<span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		find</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 如果有参数以连字符（-）打头，则猜测是 find 的参数，</span></span><br><span class="line">		<span class="comment"># 比如 -name -type 之类的。</span></span><br><span class="line">		<span class="comment"># 如果参数没有以连字符打头的，则猜测是 file 的参数，参数</span></span><br><span class="line">		<span class="comment"># 都是文件名</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;i:0:1&#125;</span>&quot;</span> = <span class="string">&#x27;-&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">				expect_find=y</span><br><span class="line">				<span class="built_in">break</span></span><br><span class="line">			<span class="keyword">fi</span></span><br><span class="line">		<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$expect_find</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">			find <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			file <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用看起来还不错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% 18:56:38 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f</span><br><span class="line">.</span><br><span class="line">./a.md</span><br><span class="line">% 18:56:40 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f &lt; a.md</span><br><span class="line">/dev/stdin: UTF-8 Unicode text</span><br><span class="line">% 18:56:42 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f -type f</span><br><span class="line">./a.md</span><br><span class="line">% 18:56:45 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 f a.md</span><br><span class="line">a.md: UTF-8 Unicode text</span><br></pre></td></tr></table></figure>

<p>这样基本符合日常使用，无法处理的边边角角的情况打全名也不是不能接受啦。</p>
<p>还有一些类似的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c()</span><br><span class="line">&#123;</span><br><span class="line">	# 复制？还是复制到剪贴板？</span><br><span class="line">	if [ -t 0 ] &amp;&amp; [ &quot;$#&quot; -ge 2 ]; then</span><br><span class="line">		cp &quot;$@&quot;</span><br><span class="line">	else</span><br><span class="line">		clip &quot;$@&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line">&#123;</span><br><span class="line">	# 调用分页器（pager）？还是打印当前目录？</span><br><span class="line">	if [ -z &quot;$1&quot; ] &amp;&amp; [ -t 0 ]; then</span><br><span class="line">		pwd</span><br><span class="line">	else</span><br><span class="line">		less -F &quot;$@&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给小工具更多的默认行为"><a href="#给小工具更多的默认行为" class="headerlink" title="给小工具更多的默认行为"></a>给小工具更多的默认行为</h2><p>有时一些操作总是连在一起的，比如新建文件夹然后切换进去，我们可以用这样的神奇函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">md</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> || <span class="built_in">return</span></span><br><span class="line">		<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们经常将别处的文件移到当前文件夹，使用这个函数，这样我们可以省略最后那个 <code>.</code> 参数。因为奇怪的原因，只有在有且仅有一个参数时才会有这个功能。有多个参数时总会有无法解决的歧义问题。（不过这样已经足够好了）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">m</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> too few arguments</span><br><span class="line">	<span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> .</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，执行 <code>cd</code> 再执行 <code>ls</code> 应该是某种常规的操作，每年因为这项操作没有优化，无数根手指被磨短。当然可以把 <code>cd</code> 变成 <code>cd &amp;&amp; ls</code>，但是我们想到了一种更加酷炫的方法来解决这个问题，放在另一个部分说。</p>
<h2 id="开启大量-shell-内置特性"><a href="#开启大量-shell-内置特性" class="headerlink" title="开启大量 shell 内置特性"></a>开启大量 shell 内置特性</h2><p>bash 内置了大量方便的扩展特性，这些特性可以使用 <code>shopt -s &lt;特性名称&gt;</code> 打开。比如：<code>shopt -s autocd</code>。</p>
<h3 id="autocd"><a href="#autocd" class="headerlink" title="autocd"></a>autocd</h3><p>自动切换目录……意思是假设当前目录下有一个名为 <code>my-doc</code> 的子目录，可以用 <code>my-doc</code> 取代 <code>cd my-doc</code>。这有一个小问题，由于补全时 bash 并不知道想输入的是目录还是指令，指令会和目录一起进入补全列表，又慢又难选。使用 <code>./my-doc</code> 会好很多。</p>
<h3 id="checkwinsize"><a href="#checkwinsize" class="headerlink" title="checkwinsize"></a>checkwinsize</h3><p>在终端窗口变化时重新设置 <code>$LINES</code> 和 <code>$COLUMNS</code></p>
<h3 id="dotglob"><a href="#dotglob" class="headerlink" title="dotglob"></a>dotglob</h3><p>匹配隐藏文件，这个按个人需求而定？我是觉得这个选项很酷所以打开了。</p>
<h3 id="extglob"><a href="#extglob" class="headerlink" title="extglob"></a>extglob</h3><p>扩展的匹配，完全没用！真的好难用，试图给通配符加上一些正则表达式的扩展，还没有 <code>find</code> <code>sed</code> <code>grep</code> <code>xargs</code> 香。</p>
<h3 id="failglob"><a href="#failglob" class="headerlink" title="failglob"></a>failglob</h3><p>没有匹配时报错而不是将模式作为参数传递给程序。非常有用，能避免一堆奇奇怪怪问题。比如：</p>
<p>开启前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% 19:21:49 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 touch *.c # 我要摸摸所有 c 文件</span><br><span class="line">% 19:21:49 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 ls</span><br><span class="line"> a.md  &#x27;*.c&#x27; # 啊不好了，他给我新建了一个 ./*.c</span><br></pre></td></tr></table></figure>

<p>开启后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 19:23:23 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 touch *.c</span><br><span class="line">-bash: no match: *.c # 没有找到！</span><br><span class="line">% [1] 19:23:28 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 ls</span><br><span class="line">a.md</span><br></pre></td></tr></table></figure>

<h3 id="globstar"><a href="#globstar" class="headerlink" title="globstar"></a>globstar</h3><p>让 <code>**</code> 通配符支持递归进子文件夹的匹配，比如 my&#x2F;**&#x2F;file 可以匹配 my&#x2F;magic&#x2F;powerful&#x2F;fancy&#x2F;file ，可以用来部分代替 <code>find</code>。</p>
<h2 id="全自动的-ls"><a href="#全自动的-ls" class="headerlink" title="全自动的 ls"></a>全自动的 ls</h2><p>有时我们希望当前目录下文件发生改变，或工作目录发生改变时，自动 <code>ls</code> 一下展示目录现状。</p>
<p>我们很容易写出这样的函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次运行，保存工作目录和当前目录内容（的哈希值）</span></span><br><span class="line">LAST_LS=$(<span class="built_in">command</span> <span class="built_in">ls</span> | <span class="built_in">sum</span>)</span><br><span class="line">LAST_PWD=<span class="string">&quot;<span class="variable">$PWD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_prompt_smart_ls</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">local</span> this_ls</span><br><span class="line">	this_ls=$(<span class="built_in">command</span> <span class="built_in">ls</span> | <span class="built_in">sum</span>)</span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$LAST_LS</span>&quot;</span> != <span class="string">&quot;<span class="variable">$this_ls</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$LAST_PWD</span>&quot;</span> != <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		LAST_LS=<span class="string">&quot;<span class="variable">$this_ls</span>&quot;</span></span><br><span class="line">		LAST_PWD=<span class="string">&quot;<span class="variable">$PWD</span>&quot;</span></span><br><span class="line">		<span class="built_in">ls</span></span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，每调用一次 <code>_prompt_smart_ls</code>，它都会检查工作目录和当前目录内容，如果发现有不一样的地方，就 <code>ls</code> 一次。我们只要想办法每执行一次指令，就调用一次这个函数就行了。</p>
<p>（当然也可以用其他的检查方式，比如使用神奇的守护进程监视文件系统变化，再和 shell 通信，但是其他方法好像都没有每执行完一次指令就检查一次简单有效）</p>
<p>怎么做到每执行一次命令，就调用一次函数呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROMPT_COMMAND=<span class="string">&#x27;_prompt_smart_ls&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用 bash 魔法变量，bash 会在执行每条命令后自动执行 <code>PROMPT_COMMAND</code> 这个变量里所存的命令。</p>
<p>最后效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% 20:17:09 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 touch test</span><br><span class="line">a.md  test</span><br><span class="line">% 20:17:12 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 rm test</span><br><span class="line">a.md</span><br><span class="line">% 20:17:13 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr</span><br><span class="line">0 cd /</span><br><span class="line">bin/   dev/  home/  lib/    lost+found/  mnt/  proc/  run/   srv/  tmp/  var/</span><br><span class="line">boot/  etc/  init*  lib64/  media/       opt/  root/  sbin/  sys/  usr/</span><br></pre></td></tr></table></figure>

<p>太炫酷了！</p>
<h2 id="更多的-cd"><a href="#更多的-cd" class="headerlink" title="更多的 cd"></a>更多的 cd</h2><p>我们知道设置了 <code>autocd</code> 之后，输入 <code>..</code> 会自动切换到上级目录……我们可以做得更多！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ...=<span class="string">&#x27;cd ../..&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ....=<span class="string">&#x27;cd ../../../&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用外部工具！"><a href="#使用外部工具！" class="headerlink" title="使用外部工具！"></a>使用外部工具！</h2><p>仔细想了想，发现平时使用 <code>z.sh</code> 按访问频率自动跳转时，有时会跳转到自己不希望的位置，如果能够选择跳转到哪里就好了。</p>
<p>我们还需要可见的界面！这个想法是从 zsh 的补全里偷来的，感觉可以上下左右选择非常厉害。</p>
<p>所以使用 <code>fzf</code> 配合 <code>z.sh</code>，做出非常友好的跳转方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fz</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">local</span> <span class="built_in">dir</span></span><br><span class="line">	<span class="built_in">dir</span>=<span class="string">&quot;<span class="subst">$(z | sed &#x27;s/^[0-9. \t]*//&#x27; |fzf -1 -0 --no-sort --tac +m)</span>&quot;</span> &amp;&amp; \</span><br><span class="line">		<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> || <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正确的重新加载配置的方法"><a href="#正确的重新加载配置的方法" class="headerlink" title="正确的重新加载配置的方法"></a>正确的重新加载配置的方法</h2><p>修改了 <code>.bashrc</code> 文件，想要试用一番！怎么加载配置文件呢？</p>
<p><code>source ~/.bashrc</code>：不好，前任配置文件中残留的 alias 尸体、环境变量可能会影响使用，尤其是写错了的情况下……</p>
<p><code>bash</code>：不好，退出的时候也要连按许多 exit 或者 Ctrl-D</p>
<p><code>bash; exit</code>：比上一个好，但是会影响 <code>$SHLVL</code> 变量，可能会对一些奇特脚本（比如 debian 11 下的 <code>~/.bash_logout</code>）造成影响。</p>
<p><code>exec bash</code>：非常好！用了 <code>exec bash</code>，亩产一千八！</p>
<p>所以这是重新加载配置文件的缩写（reload）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> rl=<span class="string">&#x27;exec bash&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>打键盘是不错，但是也别敲过了头。打键盘打得太多，手指可就被磨短了。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.356Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">12 分钟读完 (大约1768个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/toc-for-cnblogs/main/">博客园上可用的 markdown 目录生成器</a></p><div class="content"><p>为 markdown 写的文章生成目录，使其在博客园上可用。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> v5.<span class="number">12</span>;</span><br><span class="line"><span class="keyword">use</span> utf8;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:utf8&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:std&#x27;</span>, <span class="string">&#x27;:utf8&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> @subtitle_number;</span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;# 目录&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (&lt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> /^<span class="string">``</span><span class="string">`/ ... /^`</span><span class="string">``</span>/;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^(#+)\s*(.*?)\s*$/</span>) &#123;</span><br><span class="line">        <span class="keyword">my</span> ($level, $title) = (<span class="keyword">length</span>($1), $2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">my</span> $indent = <span class="string">&quot;  &quot;</span> <span class="keyword">x</span> $level;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">my</span> $id = $title;</span><br><span class="line">        $id =~ <span class="regexp">s/[^_[:^punct:]]//g</span>;</span><br><span class="line">        $id =~ <span class="regexp">s/[[:space:]]/-/g</span>;</span><br><span class="line">        $id = <span class="keyword">lc</span> $id;</span><br><span class="line"></span><br><span class="line">        @subtitle_number = <span class="keyword">splice</span> @subtitle_number, <span class="number">0</span>, $level;</span><br><span class="line">        $subtitle_number[$level - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">my</span> $subtitle_number = <span class="keyword">join</span> <span class="string">&quot;.&quot;</span>, @subtitle_number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">say</span> <span class="string">&quot;$indent+ $subtitle_number [$title](#$id)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">say</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这是一个 Perl 脚本，从 stdin 或者参数中读取文章，输出一份 markdown 代码，是文章的目录。可以直接复制粘贴使用，也可以和其他工具集成使用。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>使用这样的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl toc.pl main.md</span><br></pre></td></tr></table></figure>

<p>可以得到这样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 目录</span><br><span class="line">  + 1 [完整代码](#完整代码)</span><br><span class="line">  + 2 [使用示例](#使用示例)</span><br><span class="line">  + 3 [原理](#原理)</span><br><span class="line">    + 3.1 [HTML 的链接语法](#html-的链接语法)</span><br><span class="line">    + 3.2 [markdown 列表缩进](#markdown-列表缩进)</span><br><span class="line">  + 4 [代码详解](#代码详解)</span><br><span class="line">    + 4.1 [使用「现代」Perl](#使用现代perl)</span><br><span class="line">    + 4.2 [支持 utf8 编码](#支持-utf8-编码)</span><br><span class="line">    + 4.3 [主循环](#主循环)</span><br><span class="line">      + 4.3.1 [跳过 markdown 的代码片段](#跳过-markdown-的代码片段)</span><br><span class="line">      + 4.3.2 [匹配标题](#匹配标题)</span><br><span class="line">      + 4.3.3 [设置缩进](#设置缩进)</span><br><span class="line">      + 4.3.4 [从标题名字中获得其 id](#从标题名字中获得其-id)</span><br><span class="line">      + 4.3.5 [获取标题的编号](#获取标题的编号)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="HTML-的链接语法"><a href="#HTML-的链接语法" class="headerlink" title="HTML 的链接语法"></a>HTML 的链接语法</h2><p>在大多数网页上，markdown 的链接语法会被编译成 HTML 的 <code>&lt;a&gt;</code> 标签。通常 <code>&lt;a&gt;</code> 标签会有 <code>href</code> 属性，内容是点击标签时跳转的目的地址。</p>
<p>有些页内元素带有 <code>id</code> 属性，比如这个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;interactive-shell&quot;</span>&gt;</span>interactive shell<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子里 <code>&lt;h3&gt;</code> 标签有 <code>id</code> 属性，值是 <code>interactive-shell</code>。这个值同样可以用作 <code>&lt;a&gt;</code> 标签的目的地址。</p>
<p>当目的地址是页内元素的 <code>id</code> 时，点击 <code>&lt;a&gt;</code> 标签时便会跳转到该元素的位置。博客园给每个标题都自动分配了一个 <code>id</code>，利用这几点，就可以实现「点击目录项目跳转到对应章节」的功能。</p>
<h2 id="markdown-列表缩进"><a href="#markdown-列表缩进" class="headerlink" title="markdown 列表缩进"></a>markdown 列表缩进</h2><p>在 markdown 中，列表以 <code>+</code> <code>-</code> 和 <code>*</code> 开头。如果这些符号前面有空白字符，那么这些空白字符会被当成缩进，最终会体现在列表展示结果上，缩进越多的列表项目展示时会越靠右，缩进相同的列表项目会左对齐。利用这一点，可以实现目录的层次结构。</p>
<h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><h2 id="使用「现代」Perl"><a href="#使用「现代」Perl" class="headerlink" title="使用「现代」Perl"></a>使用「现代」Perl</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> v5.<span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>Perl 是个老古董语言，为了保持兼容性，有许多好玩&#x2F;有用的特性默认没有打开。不过我们可以使用 <code>use vX.YY</code> 的 pragma 来指定自己想使用的 Perl 的版本号，从而开启这些好玩的特性。</p>
<h2 id="支持-utf8-编码"><a href="#支持-utf8-编码" class="headerlink" title="支持 utf8 编码"></a>支持 utf8 编码</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> utf8;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:utf8&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">&#x27;:std&#x27;</span>, <span class="string">&#x27;:utf8&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>同上，因为 Perl 是个老古董语言，所以默认全世界都用 ASCII 编码。我们要开启它对 utf8 的支持。</p>
<p>这里第一行是让 Perl 用 utf8 的方式来解释这份源代码（有点像 python2 里面的 <code># -*- coding: utf-8 -*-</code> 的 pragma）。</p>
<p>第二行是让 Perl 读所有文件时，读后解码 utf8；写所有文件时，写前编码 utf8。Perl 中为了方便数据处理，存在 IO Layer 的概念。layer 可以看做数据的转换器，数据在进行输入&#x2F;输出时，会经过这些 layer 逐层处理。常用的 layer 有 <code>:crlf</code>（读时将 <code>CR-LF</code> 序列转换成 <code>CR</code>，写时反过来，用来对付 Windows 系统）和 <code>:encoding</code>（用来编解码文件）。还有些邪恶的 layer 可以实现自动压缩解压、base16 编码等功能。所以有时遇到输出到 stdout 和输出到文件中，内容不一致的情况，可以检查一下是不是用的 layer 不同造成的。</p>
<p>第三行是在设置 stdio 的 layer。因为 stdio 在 Perl 程序运行前就已经打开了，所以需要单独设置一下。</p>
<h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><p>就是那个巨大的 <code>while</code> 循环。它每次会从输入中读取一行数据并放到 <code>$_</code> 里面，直到读到文件结束。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (&lt;&gt;) &#123;</span><br></pre></td></tr></table></figure>

<p>可以发现我们并没有处理命令行参数，这是因为 <code>&lt;&gt;</code> 这个操作符会替我们完成这项工作。<code>&lt;&gt;</code> 操作符的意思是，如果有命令行参数，那么就把命令行参数当做文件名打开文件，并且将文件内容作为输入；否则就把 stdin 作为输入。每调用一次 <code>&lt;&gt;</code> 操作符会读取一行，返回这一行的内容。如果没有变量来接收 <code>&lt;&gt;</code> 操作符的返回值，那么 <code>&lt;&gt;</code> 操作符会把返回值存在特殊变量 <code>$_</code> 中。</p>
<h3 id="跳过-markdown-的代码片段"><a href="#跳过-markdown-的代码片段" class="headerlink" title="跳过 markdown 的代码片段"></a>跳过 markdown 的代码片段</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">next</span> <span class="keyword">if</span> /^<span class="string">``</span><span class="string">`/ ... /^`</span><span class="string">``</span>/;</span><br></pre></td></tr></table></figure>

<p>这一行用来跳过 markdown 的代码片断。是一种被称为 flip-flop 的语法。上面代码的意思是，「如果在两个代码标记之间，那么执行 <code>next</code> 语句」。大概和下面的东西等价：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这句在循环外头</span></span><br><span class="line"><span class="keyword">my</span> $in_codeblock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这下面的在循环里头</span></span><br><span class="line"><span class="keyword">if</span> ($in_codeblock) &#123;</span><br><span class="line">    <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/^```/</span> &amp;&amp; $in_codeblock == <span class="number">0</span>) &#123;</span><br><span class="line">    $in_codeblock = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/^```/</span> &amp;&amp; $in_codeblock == <span class="number">1</span>) &#123;</span><br><span class="line">    $in_codeblock = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flip-flop 是一种很方便的语法，可以让人少写很多代码。最重要的是不需要对那一堆烦人的标志变量命名了。</p>
<h3 id="匹配标题"><a href="#匹配标题" class="headerlink" title="匹配标题"></a>匹配标题</h3><p>用一个正则表达式来匹配标题并且获得需要的信息：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/^(#+)\s*(.*?)\s*$/</span>) &#123;</span><br><span class="line">    <span class="keyword">my</span> ($level, $title) = (<span class="keyword">length</span>($1), $2);</span><br></pre></td></tr></table></figure>

<p>这个意思是，如果遇到「开头是若干个 <code>#</code>，中间有一堆字符」这种模式，就认为匹配到标题了。<code>$level</code> 和 <code>$title</code> 分别是标题的层级和名称。因为正则表达式在 Perl 中用的特别多，所以直接做进语言里面去了，可以随手写，不需要另外调库。</p>
<h3 id="设置缩进"><a href="#设置缩进" class="headerlink" title="设置缩进"></a>设置缩进</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $indent = <span class="string">&quot;  &quot;</span> <span class="keyword">x</span> $level;</span><br></pre></td></tr></table></figure>

<p><code>$level</code> 总是个整数。这里用字符串重复操作符 <code>x</code>，来获得与 <code>$level</code> 成正比的缩进长度。</p>
<h3 id="从标题名字中获得其-id"><a href="#从标题名字中获得其-id" class="headerlink" title="从标题名字中获得其 id"></a>从标题名字中获得其 id</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $id = $title;</span><br><span class="line">$id =~ <span class="regexp">s/[^_[:^punct:]]//g</span>;</span><br><span class="line">$id =~ <span class="regexp">s/[[:space:]]/-/g</span>;</span><br><span class="line">$id = <span class="keyword">lc</span> $id;</span><br></pre></td></tr></table></figure>

<p>博客园会根据标题名称来设置其 HTML 标签的 id。有人托梦告诉我说，id 就是标题去掉所有标点符号但是保留下划线 <code>_</code>，把空白字符换成连字符 <code>-</code>，并且把所有字母变为小写之后的结果。所以用正则表达式写了一个。</p>
<h3 id="获取标题的编号"><a href="#获取标题的编号" class="headerlink" title="获取标题的编号"></a>获取标题的编号</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@subtitle_number = <span class="keyword">splice</span> @subtitle_number, <span class="number">0</span>, $level;</span><br><span class="line">$subtitle_number[$level - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">my</span> $subtitle_number = <span class="keyword">join</span> <span class="string">&quot;.&quot;</span>, @subtitle_number;</span><br></pre></td></tr></table></figure>

<p>生成的目录里面会有类似 <code>X.Y.Z.W</code> 这样的标题编号。这一部分代码就用来处理标题编号的生成问题。懒得写了……</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-01T17:48:39.000Z" title="10/1/2023, 5:48:39 PM">2023-10-01</time>发表</span><span class="level-item"><time dateTime="2024-01-13T13:43:01.360Z" title="1/13/2024, 1:43:01 PM">2024-01-13</time>更新</span><span class="level-item">7 分钟读完 (大约1058个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/tutorial/wine-bottles/main/">Bottles 安装</a></p><div class="content"><h1 id="Bottles-安装"><a href="#Bottles-安装" class="headerlink" title="Bottles 安装"></a>Bottles 安装</h1><h2 id="好名字！"><a href="#好名字！" class="headerlink" title="好名字！"></a>好名字！</h2><p><a target="_blank" rel="noopener" href="https://docs.usebottles.com/">Bottles</a> 是类似 winetricks 的小软件，用于自动配置 wine、自动安装并配置软件。至于为什么有了 winetricks 还需要新的小软件，bottles 在他们官网上给出了<a target="_blank" rel="noopener" href="https://docs.usebottles.com/faq/where-is-winetricks">解释</a>：bottles 希望提供中心化的依赖处理系统，并且希望拥有比 winetricks 更强的扩展性。总之不是重复造轮子就对了。</p>
<p>之前试着用 winetricks 一键安装 qq，结果有一个托管在 ftp.hp.org 上的文件一直下载不下来。接着我就把 winetricks 扬了。</p>
<p>Wine bottles，酒瓶子。:D</p>
<h2 id="安装和安装过程的问题修复"><a href="#安装和安装过程的问题修复" class="headerlink" title="安装和安装过程的问题修复"></a>安装和安装过程的问题修复</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.usebottles.com/getting-started/installation">官方的安装指南</a></p>
<h3 id="直接使用包管理器安装"><a href="#直接使用包管理器安装" class="headerlink" title="直接使用包管理器安装"></a>直接使用包管理器安装</h3><p><a target="_blank" rel="noopener" href="https://docs.usebottles.com/getting-started/installation">官方的安装指南</a>里面说，bottles 在多个发行版的源里有包。比如 fedora，就可以使用 <code>sudo dnf install bottles</code> 来安装。其他支持的发行版可以去安装指南里头看看。</p>
<p>但是 debian 源竟然没有包，神奇……明明代码目录里有个 <code>debian/</code>，这不指明了是要人打包吗？</p>
<h3 id="编译-deb-包，再使用包管理器安装"><a href="#编译-deb-包，再使用包管理器安装" class="headerlink" title="编译 deb 包，再使用包管理器安装"></a>编译 deb 包，再使用包管理器安装</h3><h4 id="编译-deb-包"><a href="#编译-deb-包" class="headerlink" title="编译 deb 包"></a>编译 deb 包</h4><p>因为 debian 源里面没有 bottles 的包，所以我们需要编译代码。同时为了维护依赖，便于删除，我们利用代码目录里面 <code>debian/</code> 下的东西把它打成 deb 包，再使用 <code>apt</code> 命令安装。</p>
<p>bottles 使用 meson 和 ninja 作为构建系统。听说这两个东西很先进，打算改天去学一下。从 <a target="_blank" rel="noopener" href="https://blog.devgenius.io/how-to-build-debian-packages-from-meson-ninja-d1c28b60e709">devgenius.io</a> 上现学了怎么使用 meson&#x2F;ninja 打 deb 包：</p>
<ol>
<li>首先安装 <code>debhelper</code> <code>build-essentials</code> 和 <code>dh-make</code>。其中 <code>debhelper</code> 和 <code>dh-make</code> 是 debian 的软件包构建相关工具。<code>build-essentials</code> 则是软件开发的基础工具，包含 <code>make</code> 等小工具。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install debhelper build-essentials dh-make</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接着下载代码并且进入环境：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bottlesdevs/Bottles</span><br><span class="line"><span class="built_in">cd</span> Bottles</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后运行 debian 包的自动配置脚本，指定构建系统为 meson：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dh_auto_configure --buildsystem=meson</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后运行构建软件包的命令。参数的 <code>-b</code> 是指仅构建二进制的 deb 包。因为是命令是偷来的所以也不是很清楚参数有什么用……</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-buildpackage -rfakeroot -us -uc -b</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>回到上级目录，发现 deb 包出现了！</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../ &amp;&amp; <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total 284</span><br><span class="line">drwxrwxr-x 1 root root    672 Mar  5 20:02 Bottles-2022.2.28-trento-2/</span><br><span class="line">-rw-r--r-- 1 root root   6872 Mar  5 20:02 com.usebottles.bottles_2022.2.28-trento-2_amd64.buildinfo</span><br><span class="line">-rw-r--r-- 1 root root   5004 Mar  5 20:02 com.usebottles.bottles_2022.2.28-trento-2_amd64.changes</span><br><span class="line">-rw-r--r-- 1 root root 269408 Mar  5 20:02 com.usebottles.bottles_2022.2.28-trento-2_amd64.deb</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>安装</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install ./com.usebottles.bottles.*.deb</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>检查有没有 bottles 命令</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> bottles</span><br></pre></td></tr></table></figure>

<p>如果出现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bottles is /usr/bin/bottles</span><br></pre></td></tr></table></figure>

<p>说明安装成功！</p>
<h2 id="启动和启动过程的问题修复"><a href="#启动和启动过程的问题修复" class="headerlink" title="启动和启动过程的问题修复"></a>启动和启动过程的问题修复</h2><p>在我这儿 bottles 安装好后运行命令并不能直接启动，会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% [1] 20:43:10 jyi@Syameimaru-Aya ~</span><br><span class="line">0 bottles</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/bottles&quot;, line 56, in &lt;module&gt;</span><br><span class="line">    from bottles import main</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/main.py&quot;, line 32, in &lt;module&gt;</span><br><span class="line">    from bottles.window import MainWindow</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/window.py&quot;, line 35, in &lt;module&gt;</span><br><span class="line">    from bottles.views.details import DetailsView</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/views/details.py&quot;, line 25, in &lt;module&gt;</span><br><span class="line">    from bottles.views.bottle_details import BottleView</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/views/bottle_details.py&quot;, line 36, in &lt;module&gt;</span><br><span class="line">    from bottles.dialogs.generic import MessageDialog</span><br><span class="line">  File &quot;/usr/share/bottles/bottles/dialogs/generic.py&quot;, line 20, in &lt;module&gt;</span><br><span class="line">    gi.require_version(&#x27;GtkSource&#x27;, &#x27;4&#x27;)</span><br><span class="line">  File &quot;/usr/lib/python3/dist-packages/gi/__init__.py&quot;, line 129, in require_version</span><br><span class="line">    raise ValueError(&#x27;Namespace %s not available for version %s&#x27; %</span><br><span class="line">ValueError: Namespace GtkSource not available for version 4</span><br></pre></td></tr></table></figure>

<p>经过搜索发现这里是缺少了 <code>gir1.2-gtksource-4</code> 的库。估计是写依赖时写漏了。使用 <code>sudo apt install gir1.2-gtksource-4</code> 安装上就可以正常运行了。</p>
<h2 id="简易使用"><a href="#简易使用" class="headerlink" title="简易使用"></a>简易使用</h2><p>安装运行之后会出现欢迎界面，点几下 “下一步” 之后 bottles 会下载相关组件。这个很慢，可能是因为服务器在国外。多等一会儿就好了。等的时候可以写写博客之类的……</p>
<p>之后使用方式非常显然，所以就不写了（咕了）。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://avatars.githubusercontent.com/u/86813521" alt="jyi2ya"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">jyi2ya</p><p class="is-size-6 is-block">大学生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国湖南</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jyi2ya" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jyi2ya"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/feed.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-01T17:48:39.000Z">2023-10-01</time></p><p class="title"><a href="/2023/10/01/fun/niulang-zhinv/main/">【睡前故事】牛郎织女的故事</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-01T17:48:39.000Z">2023-10-01</time></p><p class="title"><a href="/2023/10/01/fun/perl-is-fun/main/">后现代编程语言介绍</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-01T17:48:39.000Z">2023-10-01</time></p><p class="title"><a href="/2023/10/01/nonsense/friends/main/">友链</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-01T17:48:39.000Z">2023-10-01</time></p><p class="title"><a href="/2023/10/01/nonsense/rerestart/main/">重新重新开始</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-01T17:48:39.000Z">2023-10-01</time></p><p class="title"><a href="/2023/10/01/nonsense/restart/main/">重新开始</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">jyi2ya 的博客</a><p class="is-size-7"><span>&copy; 2024 jyi2ya</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>